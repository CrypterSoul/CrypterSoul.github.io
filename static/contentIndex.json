{"01背包":{"title":"01背包","links":[],"tags":["算法"],"content":"集合：\n在前i件物品中，选择总体积不超过j的物品的所有选择方案\n属性：\n集合中所有选择方案中，价值最大的方案的价值\n状态计算：\n集合划分为：包含了第i件物品f[i - 1, j - v[i]]+w[i]和不包含第i件物品f[i-1,j]\n状态转移方程：\nf[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i])\n结果：f[m][n]\n可以压缩成一维\nfor (int i = 1; i &lt;= m; i++) {\n\tfor (int j = n; j &gt;= w[i]; j--) {\n\t\tf[j] = max(f[j], f[j - w[i]] + v[i]);\n\t}\n}"},"CLRS":{"title":"CLRS","links":[],"tags":[],"content":"分治算法 矩阵乘法的例子\n归纳法 主定理证明\n尝试放宽上界 主定理要求多项式意义下的比较"},"Daily/2022-10-04":{"title":"2022-10-04","links":[],"tags":[],"content":"STFW (Search The Fuckking Web)向别人求助之前自己先尝试通过正确的方式使用搜索引擎独立寻找解决方案.\nRTFM是STFW的长辈, 在互联网还不是很流行的年代, RTFM是解决问题的一种有效方法. 这是因为手册包含了查找对象的所有信息, 关于查找对象的一切问题都可以在手册中找到答案.\n你或许会觉得翻阅手册太麻烦了, 所以可能会在百度上随便搜一篇博客来尝试寻找解决方案. 但是, 你需要明确以下几点:\n\n你搜到的博客可能也是转载别人的, 有可能有坑\n博主只是分享了他的经历, 有些说法也不一定准确\n搜到了相关内容, 也不一定会有全面的描述\n\n最重要的是, 当你尝试了上述方法而又无法解决问题的时候, 你需要明确”我刚才只是在尝试走捷径, 看来我需要试试RTFM了”."},"Daily/2022-10-09":{"title":"2022-10-09","links":[],"tags":[],"content":"STFW - Search The Fucking Web\n\n只要我用的工具是大众的, 我几乎不可能是世界上第一个遇到问题的人\n网上一定有人遇到过相同/类似问题, 我应该搜一下看看他们怎么解决\n\nRTFM - Read The Fucking Manual\n\n只要我用的工具是大众的, 应该有手册记录这个工具的所有细节\n如果我想了解它的某个问题, 我应该去搜索手册的描述\n\nRTFSC - Read The Fucking Source Code\n\n只要我获得了项目代码, 理论上我就可以知晓它的一切行为\n如果我想了解它具体是如何工作的, 我应该去读一下(关键)代码\n\n如果你在提问时收到了这些回复, 其背后的含义是:\n\n你想要的答案很容易找到, 你很应该自己去获取\n相比于我直接告诉你答案, 你自己获取答案能学到更多\n\nurl: https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md#rtfm-%E5%92%8C-stfw%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%BD%A0%E5%B7%B2%E5%AE%8C%E5%85%A8%E6%90%9E%E7%A0%B8%E4%BA%86\ntitle: &quot;How-To-Ask-Questions-The-Smart-Way/README-zh_CN.md at main · ryanhanwu/How-To-Ask-Questions-The-Smart-Way&quot;\ndescription: &quot;本文原文由知名 Hacker Eric S. Raymond 所撰寫，教你如何正確的提出技術問題並獲得你滿意的答案。 - How-To-Ask-Questions-The-Smart-Way/README-zh_CN.md at main · ryanhanwu/How-To-Ask-Questions-The-Smart-Way&quot;\nhost: github.com\nfavicon: https://github.githubassets.com/favicons/favicon.svg\nimage: https://repository-images.githubusercontent.com/33041711/b9155c00-e8b9-11ea-9060-9a2a69ad2d6e\nurl: https://github.com/tangx/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md\ntitle: &quot;Stop-Ask-Questions-The-Stupid-Ways/README.md at master · tangx/Stop-Ask-Questions-The-Stupid-Ways&quot;\ndescription: &quot;Stop-To-Ask-Questions-The-Stupid-Ways. Contribute to tangx/Stop-Ask-Questions-The-Stupid-Ways development by creating an account on GitHub.&quot;\nhost: github.com\nfavicon: https://github.githubassets.com/favicons/favicon.svg\nimage: https://opengraph.githubassets.com/efb72f7c4694d4f11f9e55392c22d9743d664deb2204d844f5cbae88570432cc/tangx/Stop-Ask-Questions-The-Stupid-Ways"},"Daily/2023-08-19":{"title":"2023-08-19","links":[],"tags":[],"content":"failed to synchronize all databases (unable to lock database) §\n解决方法：删除/var/lib/pacman/db.lck\nwsl docker图形化解决方案\nwslg/samples/container/Containers.md at main · microsoft/wslg (github.com)\nmacos x11转发踩坑\nssh - OpenGL rendering with X11 forwarding - Unix &amp; Linux Stack Exchange --- ssh - 使用X11转发的OpenGL渲染 - 智库101 - 一个基于CC版权的问答分享平台"},"Daily/2023-08-22":{"title":"2023-08-22","links":[],"tags":[],"content":"136. 只出现一次的数字 - 力扣（LeetCode）\n异或运算"},"Daily/2023-10-15":{"title":"2023-10-15","links":[],"tags":[],"content":"系统调用不设置返回值时\n以write调用的行为来看，好像是被认为没有输出成功从而会反复尝试重新输出第一个字符，具体真相有待继续研究 存疑"},"Daily/2023-10-23":{"title":"2023-10-23","links":[],"tags":[],"content":"更多CPU §\nDMA，设备管理器，总线管理器，显卡\n可以认为是完成一些特定任务的CPU\n否则CPU没法做到在限制指令条数的情况下完成一些任务（如拷贝大量数据到屏幕寄存器上）\n消除简洁左递归的方法的使用要求 §\n文法中不存在环\nA=∗&gt;A\n文法中不存在ε产生式\nLL(0)文法 §\n一个字符也不往前看\n可能的语言是 只有一个字符串 或者对于每一个终结符 产生式唯一 不需要作选择\nIPC和频率 §\n为什么时钟频率不能完全反映性能，因为只是时钟数，还需要看IPC（目前理解）\n上下文相关文法 §\nL={anbncn∣n≥1}\n正则表达式的表达能力 §\n严格弱于上下文无关文法\n证明方法：先证明所有正则表达式都能用上下文无关文法描述，构造自动机\n再找到一个不能用正则表达式表述的上下文无关文法Pumping lemma\nL={anbn∣n≥1}\n怎么证明他不能用正则表达式表述\n有限状态自动机的状态有限\n前递 §\n单单从时空图来看，就是允许拿上一个时间写进某个流水级之间的寄存器的值作为输入"},"Daily/2023-10-24":{"title":"2023-10-24","links":[],"tags":[],"content":"设备 §\n可分为字符设备和块设备\n设备支持read,write,ioctl（读写设备配置）\n字符设备 终端tty\n块设备 磁盘\nLinux Block I/O Layer\n文件系统和磁盘设备之间的层\n一些有趣的设备 /dev/null /dev/0 随机数设备等等\n万物皆文件\n什么是设备驱动\n系统调用遵从设备specification的实现 翻译成设备需要执行的\n简洁的系统调用接口将复杂性扔给了其实现\nlinux中最臭最大的一块 设备驱动\n文件系统的抽象\n文件是一种虚拟磁盘\n文件挂载 回环设备"},"Daily/2023-10-25":{"title":"2023-10-25","links":[],"tags":[],"content":"动态规划 §\n子问题图刻画了子问题之间的依赖关系，图上的边数点数与运行时间成正比\n钢条切割\nrn​=max(pn​,r1​+rn−1​,r2​+rn−2​,....,rn−1​+r1​)\n更简单的求解方式\nrn​=max(pi​,rn−i​)(1≤i≤n)\n矩阵连乘\n总括号化方案数\nP(n)={1∑k=1n−1​P(k)P(n−k)​n=1n⩾2​\n为卡特兰数，可能是指数级\n最优子结构\n证明方法 剪贴黏贴技术cut and paste\n无权最长路径不符合 无权最短路径符合\n因为无权最长路径中子问题之间相关，将原问题划分成两个子问题A和B，A中使用了的顶点不能在B中使用（简单路径的要求）\n重叠子问题\n刻画子问题空间 保持子问题空间尽量简单，在钢条切割问题中是子问题空间中的问题是长度为i的钢条的最优切割问题。\n只在必要时扩展它，在矩阵连乘问题中，是起始点为i，终点为j的子问题\n动态规划问题的时间复杂度\n1.子问题总数和每个子问题的选择数 两者的乘积\n2.子问题图\n最长公共子序列问题\nLCS的最优子结构\n\n试图简单阐释一下证明思路 如懂\n1.zk一定是延伸到了X和Y的末尾，否则Z可以更长，与Z是LCS矛盾\n如何证明Zk-1也是LCS，如果存在更长的Xm-1和Yn-1的LCS W，那么Z可以更长\n2和3 首先Z可以是Xm-1和Y的公共子序列…\n什么是文件 vector&lt;char&gt;\n什么是目录 map&lt;string,file-ptr&gt;\nFAT §\n面对的情况 文件数少 块数也少 直接使用链表结构\nFAT-16中的16代表”next数组”占用的bit\nnext数组标记了可能存在的该文件的下一块的位置或者坏块等等\n文件是块的链表 但是链表的next数组被同一存放在一个位置利用了局部性，存储了多个备份保证安全\n目录也是文件，目录的实际数据内容是目录项，其中也存放了文件的元信息\nLL文法改造 §\n消除左递归 提取公因子\n如何消除间接左递归，保证产生式左右两端非终结符的单调性\nll star §\n支持二义，不支持间接左递归\n三个大主题\n优先级上升算法 将递归产生循环展开，附加上优先级，通过设置优先级实现左结合右结合和运算优先级。（左结合上升一级，右结合不变）\n异常处理和从异常中恢复\nfollowing集合，一个动态分析的概念\nP={S−&gt;Ac∣Ad,A−&gt;aA∣b}\n(a*b)(c|d)\n面对bc和bd，应该如何展开S呢？这似乎是一个LL(?) 的\nlookahead dfa接受当前输入的整个前缀，告诉要选择哪个产生式\n\n和NFA转DFA的算法类似，维护一个状态集合，（对于该文法）每个状态是一个三元组(当前状态，该状态选择的探索路径，递归调用栈（应当返回的状态）)\n也就是比NFA转DFA算法多了一个调用非终结符\nReorder Buffer/Renaming table §\nRenaming table维护寄存器名的映射\n当新的指令被dispatch或者某条指令complete时应当分别被更新成 它在renaming table中的标签 和 实际值\n乱序执行受限于指令的稳定提供-控制冒险\n乱序发射并没有带来显著的性能提升\n区分complete和commit\n微体系 §\n微体系是体系结构的实现\n差分机 §\n一个函数的值可以用做差分，最后用加法器填表计算\n"},"Daily/2023-10-26":{"title":"2023-10-26","links":[],"tags":[],"content":"内存/硬盘 §\n内存层次模型在苦苦支撑一个支持随机访问的大内存模型\n但是硬盘的随机访问就不太行，所以文件系统的设计不能按内存的特性设计"},"Daily/2023-10-30":{"title":"2023-10-30","links":[],"tags":[],"content":"并发 §\n针对并发带来的问题，我们的解决方式是不要并发。\n一把大锁保平安，只在需要时拆锁，不要over design\n语法制导 §\n什么是语义？调用某个符号之前有没有声明，表达式类型\n属性文法为上下文无关文法赋予语义 SDD\n实现属性文法 SDT\n在语法分析过程中嵌入语义动作（代码），该动作在左边的所有文法符号处理好后立刻执行\n如何将SDD转为SDT？\n综合属性和继承属性都描述了信息的流动\n在依赖图中，S属性体现为自下而上的流动，继承属性则是从左向右，从上而下的 有序的信息流动\n因此从代码角度，综合属性是返回值，继承属性是调用参数\n语法制导定义 §\nSDD给每个产生式关联了一组规则，唯一确定了每个非终结符节点的属性值，但没有规定实际执行的顺序，方式\n有点像定义了一个方程组\nS属性定义是一种只有综合属性的SDD\nL属性定义是包含继承属性，但是一系列规则限制不产生环\n综合属性\n只能由该节点本身和子节点的属性来定义\n表达式求值，中缀表达式转后缀表达式可以用综合属性实现\n继承属性\n只能由父节点，本身和兄弟结点的属性来定义\n类型声明文法可以用继承属性实现\n数组类型声明和引用需要使用两种属性\n为什么？int a[2][3]在树上的顺序是int 2 3，但我们需要构造(2,(3,int))\n如何进行语义分析\n定义一些listener，在遍历树的某些时机做适当的事\noffline 再遍历语法树 有开销\nonline 语法制导 在语法分析的同时完成\n更多方式有待学习"},"Daily/2023-10-31":{"title":"2023-10-31","links":[],"tags":[],"content":"primes实验记录 §\n反复关闭同一个管道口 错误的\np = get a number from left neighbor\nprint p\nloop:\n    n = get a number from left neighbor\n    if (p does not divide n)\n        send n to right neighbor\n\n"},"Daily/2023-11-01":{"title":"2023-11-01","links":[],"tags":[],"content":"\n定理\n存在一种LR语法分析方法，保证句柄总是出现在栈顶\n定理给出了存在性证明，句柄并不一定出现在栈顶，但这可能会给我们的算法带来很多负担，因此我们使用栈顶的这种。\n\nshift移进 reduce规约/回溯 goto\n状态刻画了当前 所有观察到的针对所有产生式的右部的前缀。\n状态是项集。\n点指示了栈顶，左边是栈中内容（路径），右边是期望看到的文法符号串。\nCLOSURE({[E&#039;→.E]})\nGOTO(I,X)=CLOSURE({[A→αX⋅β]​[A→α⋅Xβ]∈I})\n接收状态\nF={I∈C∣∃[A→α⋅]∈I}\nGOTO函数被拆分成ACTION表（终结符）和GOTO表（非终结符）\nLR(0)分析表构造\nGOTO(Ii​,a)=Ij​∧a∈T⟹ACTION[i,a]←sj\nGOTO(Ii​,A)=Ij​∧A∈N⟹ACTION[i,A]←gj\n[k:A→α⋅]∈Ii​∧A=S′⟹∀t∈T∪{$}.ACTION[i,t]=rk\n[S′→S⋅]∈Ii​⟹ACTION[i,$]←acc\nLR0分析，自动机是本质，栈是实现\nLR0的0指的是规约时不需要向前看，无脑规约\nSLR(1) simple\n[k:A→α:]∈Ii​∧A=S′⟹∀t∈Follow(A).ACTION[i,t]=rk\nLR(1) SLR相较于LR(1)可能算是比较静态的\nLR(1)项中新增一个记录当前句柄之后的符号的\n[A→α⋅,a]\n只有下一个输入符号为a时，才可以规约\n[A→α⋅β,a](a∈T∪{S})\n期望剩余输入的开头可以由βa推导出（要写a是因为β可能可以推出ε）\n（只有）闭包规则的修改如下：\n[A→α⋅Bβ,a]∈I(a∈T∪{$})\n∀b∈FIRST(βa).[B→⋅γ,b]∈I\n初始状态为\nCLOSURE([S′→⋅S,$])\nLR(1)缺点是产生的状态数太多了（相当于将每个LR0项又细分开）\nLALR(1)将具有相同LR(0)项的状态合并（合并方法：先从没有出边的开始）\n得到状态数和SLR(1)相当的自动机，能力介于SLR(1)和LR(1)之间\n可以证明LALR(1)的改造不会引进规约/移入冲突\n存在方法可以直接构造LALR(1)而不是从LR(1)改造"},"Daily/2023-11-06":{"title":"2023-11-06","links":[],"tags":[],"content":"柯里化 §\n构造g(x)(y)=f(x,y)\n&gt;&gt;&gt; def curry2(f):\n        &quot;&quot;&quot;返回给定的双参数函数的柯里化版本&quot;&quot;&quot;\n        def g(x):\n            def h(y):\n                return f(x, y)\n            return h\n        return g\n&gt;&gt;&gt; def uncurry2(g):\n        &quot;&quot;&quot;返回给定的柯里化函数的双参数版本&quot;&quot;&quot;\n        def f(x, y):\n            return g(x)(y)\n        return f\n&gt;&gt;&gt; pow_curried = curry2(pow)\n&gt;&gt;&gt; pow_curried(2)(5)\n32\npython中函数在调用时可以使用其定义时所在frame上的信息\n分数维 §\n对于一个“长度”为L的n维图形\n“长度”缩放s倍，相当于“质量”缩放s^n倍\n对于二维，正方形被切成四个小正方形\n对于sierpinski三角形，二分之一的“长度”的图形“质量”变成三分之一，由此可以推导出维度"},"Daily/2023-11-08":{"title":"2023-11-08","links":[],"tags":[],"content":"页表保存在内存中，有一个寄存器SATP(riscv)指示页表的地址，进而MMU去该位置获取页表\n地址空间\n地址空间的概念使得一个进程完全不具备引用另一个进程（不属于他自己）的内存地址\n强隔离性\n页表是地址空间的一种实现方式，页表硬件上通过MMU实现"},"Daily/2023-11-13":{"title":"2023-11-13","links":[],"tags":[],"content":"Bezier曲线，递归方法de Casteljau\n展开式"},"Daily/2023-11-14":{"title":"2023-11-14","links":[],"tags":[],"content":"局部状态\ndef creator():\n    state = 0\n    def action():\n        nonlocal state    #没有这行会报错\n        state = state + 1 #出现在左边的state表示要为当前frame绑定state，那右边的state怎么办，当前frame没有state\n        print(state)\n    return action\n一个叫约束连接的有趣例子\n\n将等式用图的形式表达，实现时，“用一个个组件拼接起来”\npython中的面向对象"},"Daily/2023-11-19":{"title":"2023-11-19","links":[],"tags":[],"content":"控制流语句翻译方案\n大致上分为两种 一种是教科书上的在布尔表达式中处理跳转，另一种是不在布尔表达式中（在布尔表达式所处的结构中）处理\n在布尔表达式处理中又介绍了两种做法，一种是类似java字节码（？），没有跳转符号，直接使用地址，另一种是使用符号\n为了实现使用符号的，在布尔表达式内部处理的，控制流语句翻译，需要在父节点中设计和摆放符号，传递给子节点。\n如果是使用地址的，那么需要在子节点中挖坑，并向父节点传递欠填的坑的集合，在有足够信息的父节点处填坑。(backpatch)\n读写文件\n已有常规做法是通过系统调用read,write\n可能更好的做法是通过内存映射文件，直接将虚拟地址对应到文件内容，少了很多系统调用的开销\nriscv中ecall做了三件事情\n\n切换模式\n保存pc到sepc\n跳转到stvec所指向的指令 xv6中跳转到trampoline\n其余的事情都没有做，提供了设计灵活性\n"},"Daily/2023-11-27":{"title":"2023-11-27","links":[],"tags":[],"content":"曾经使用过的网络方案\nn2n\n现在在使用zerotier\n可能可以尝试rathole\n几种利用page fault的性能优化机制\n应该都可以归类为lazy allocation\ndemand page 快速加载程序（的text和data）exec\nzero fill demand 快速分配空白页\ncopy on write 快速fork\ndynamic analysis\n只能抓出在特定输入上出现的problematic behavior\n工具valgrind\n替换malloc为它的实现，并在读写内存时添加一些记录检查代码，可以检查是否读写了超出堆空间的内存\n优点是泛用性很强，因为不需要拿到源码\n缺点是二进制文件中信息量太少（比如栈上具体怎么将内存划给变量）\nllvm sanitizer\n更进了一步，从源码分析\n可以做到变量级，如数组出界\n提供了很多sanitizer\nfuzzing\n模糊测试，构造大量测试用例，变异\n\nstatic analysis\nlint\n一种编码规范，不等同于程序broke\ndataflow analysis\n追踪所有程序执行路径上数据的变化，可以做到检查是否正确释放资源等\n可能会错误警示一些不可能走到的路径\n适合单文件，多文件可能会unwieldy\nCool let’s sanitize/lint all the code!🔨💯"},"Daily/2023-11-28":{"title":"2023-11-28","links":[],"tags":[],"content":"xv6设计\n一个进程只有三种状态，在用户空间运行，或者在内核空间运行，或者不运行（可以理解为两个线程？）\nspinlock要处理两个事\n一个是cpu与cpu之间的并行\n一个是1个cpu上内核（这里特指中断程序）和用户之间的并行，关中断\n设备驱动分为两块\ntop部分 read/write接口\nbottom部分 中断处理程序\n这两个部分可以并行，需要锁来保护"},"Daily/2023-12-01":{"title":"2023-12-01","links":[],"tags":[],"content":"cs110l学习记录\n列举了c语言使用的一些常见问题，反复释放，悬空指针，内存泄漏，use-after-free\n展示了一些c语言项目的做法\n通过注释的形式约定谁负责管理内存，维护pre/postcondition\n然后是rust语言能在语言层面提供这种所有权的支持\n变量名是主人，等式右侧是内存对象\n一个主人持有一个对象的语义是要对该对象的内存管理负责\n一个值有且只有一个主人，主人销毁值销毁\nrust中的两种trait\ncopy trait 复制堆上的内容\n对于int32这种只在栈上的数据，浅拷贝相当于深拷贝\ndrop trait 转移持有者\n如果有copy trait就不允许使用drop trait\nrust中所有变量默认immutable（包括下述的引用类型）\n引用类型\n变量只能同时有多个不可变引用类型或者一个可变引用类型\n因此：\n当存在一个可变引用类型时，原变量暂时不可用\n当只有不可变引用类型时，原变量暂时不可变\nfn main() { \n\tlet mut v = vec![1, 2, 3]; \n\t/* This for loop borrows the vector above to do its work. */ \n\tfor i in &amp;mut v { \n\t\tprintln!(&quot;{}&quot;, i); \n\t\tv.push(34); /* can cause resize -&gt; moving in memory! */ \n\t} \n}\n分别在for循环和push处两次可变引用"},"Daily/2023-12-05":{"title":"2023-12-05","links":[],"tags":[],"content":"xv6中编译后还额外提供了.d文件\n作用是描述一个c代码的头文件依赖情况\n只需要给gcc添加一个编译选项\n因为在makefile里没法追踪一个c代码文件中头文件的改动，为此打的一个小补丁"},"Daily/2023-12-19":{"title":"2023-12-19","links":[],"tags":[],"content":"读写锁 §\n对于读者的访问，需要保证没有写者存在，保证的方式是第一个读者进入时取得写锁，最后一个读者退出时交还写锁\n对于读者数的计数，需要另一个锁来保证互斥访问\nGAMES101 光线追踪 §\n和光栅化部分的区别？\n光栅化部分缺少全局光照信息，还需要做深度测试\n光线追踪的基本idea\n相机是一个点，面对着一个屏幕，相机对屏幕上每个点发射一条观察光线，沿着方向打到最近的物体上，再从物体上的碰撞点连线光源，判断光照\n因此，也就有了我们需要关心的一个话题，如何用光线和隐式曲面，显式曲面求交，如何高效求交（空间划分，物体划分）"},"Daily/2023-12-20":{"title":"2023-12-20","links":[],"tags":[],"content":"有一种硬拖成两天的笔记记的美\n辐射度量学 §\n首先要对这几个物理量在生活中可能的对应有个概念\n\nirradience 不带方向的\n渲染方程 §\nLo​(p,ωo​)=Le​(p,ωo​)+∫Ω+​Li​(p,ωi​)fr​(p,ωi​,ωo​)(n⋅ωi​)dωi​\n其中积分域限制了只求解半球面（从内部射入的光线不应该被考虑）\nLe刻画了物体自己发光的radience\nf_r是双向分布函数brdf\n刻画了能量在不同方向上的分布\n从radience到irradience\nwhitted style的几个缺陷\n只有镜面反射，没有全局光照（color bleeding现象）"},"Daily/2023-12-23":{"title":"2023-12-23","links":[],"tags":[],"content":"什么是可执行文件\n一个数据结构，描述了状态机初始状态和迁移\n\n\n                  \n                  动手 \n                  \n                \n试着使用strace观察（可执行）文件的执行\nexecve在以下各种情况的返回值（在文档中均有描述）\n1.没有执行权限的文件\n2.非可执行文件\n3.设备\n\nshebang的语法是#!\n个人猜测可能类似vim中!的用途\n通过编写一个打印所有参数的程序，可以验证shebang的行为似乎就是替换execve参数实现\nbinutils\n数据结构的查看/操作工具\n-S\n使得编译器生成调试信息在可执行文件中\n什么是编译器 §\n将C状态（语句 stackframe）\n翻译成机器视角（指令 内存 寄存器）以及debug info\ndebug info用来做反向的过程，可以从机器的某个运行状态回推当前对应的代码，但是并不太好做\nstack unwinding §\n似乎说的就是打印某个时刻函数调用栈的信息\n在xv6中做过，通过栈上的返回地址不断回跳\njyy这里做的更巧妙，使用了链表来描述这个过程\n增加了O2优化之后，这个方法就不行了，但是gdb仍然一定程度上能做到 👍\n重定位（Relocation） §\n编译时有些跳转地址不能确定，先填0\n但是可以知道需要满足assertion\n0xa hello(); // callq 5个字节\n0xf 某个语句;\nassert( (char *)hello == \n\t\t(char *)main + 0xf + // call hello 的 next PC \n\t\t*(int32_t *)((uintptr_t)main + 0xb) // call 指令中的 offset );\n应该是因为x86指令集的跳转约定是跳到下条指令加上offset的地址，offset是我们要填的东西\n理解了这段就可以理解elf中的约定\nOffset       Type           Sym. Name + Addend \n00000000000b R_X86_64_PLT32 hello - 4\n将S+A-P填入\nP是要填入的起始位置（main+0xb）\nS是调用的函数\nA是-4，应该是要填入的位置的末尾到开头的偏移？\nP17的其他内容\n进程初始化时候内存设置的spec\nrsp指向存放arg的内存位置…\n两个loader的实现简述\n动态链接 §\n将应用程序打散\n主要是运用了这个机制\ncall *func(%rip)\n目前的合理理解是func是符号，func这个位置存放了所需的函数的绝对地址\n在export的func中存放了func相对于dl文件头的偏移，加上实际加载到内存空间后的首地址就得到了func函数的实际地址\nfunc(%rip)计算func这个标志的位置相对于rip的偏移量，反正call能跳转到func标志中指向的函数\nvoid Tsum() {\n  for (int i = 0; i &lt; N; i++) {\n    sum++;\n  }\n}\n对于多个线程执行该程序的最小可能sum结果为2（这题似乎还有假设原子读写sum）\n我的目前理解是\n一个线程读到t=sum=0，t++，然后让另一个线程执行到最后一轮，再让前一个线程保存sum=1，让另一个线程读t=sum=1，t++，然后直到所有线程结束再写回，得到2\np15的其他内容\nvsc，np complete问题，3sat\n文件描述符fork和dup时共享偏移量，并且操作是原子的\nxv6中做过的cow\n\n\n                  \n                  fork的几个用处 \n                  \n                \n并行搜索\n快速回溯 也可以backtrack的时候一下子往回跳到某个状态而不是一步步\n状态复用 fork一份完成了初始化的系统（nemu，android）\n容错试错 如果某个错误只有极小概率触发呢？\n\na fork in the road\n随着系统加入更多东西，fork越来越复杂"},"Daily/2023-12-28":{"title":"2023-12-28","links":[],"tags":[],"content":"direct initialization\n自动进行窄化，不会类型检查\nuniform initialization\n大括号，进行类型检查 安全\n各种类型都可以用这种语法\nstd::optional\nnullopt"},"Daily/2024-01-06":{"title":"2024-01-06","links":[],"tags":[],"content":"lec6 lec7\nrust是和c/c++一样的explicit memory management的语言\n讲了GC\n讲了rust实现链表\nbox\n类似c++中的uniqueptr\nlec8\ntrait 用来实现rust的面向对象（？）\n可插入现有结构的代码段（其中可以含有对self的引用）\n不需要完全定义（可以像java接口）\n避免了像c++那样完全地从父类继承，形成一个复杂的依赖层次结构，一发动全身\n几种需要知道的trait\ncopy 实现了之后赋值时不再转移所有权 而是复制一份\nclone\ndrop 如何释放内存，抵达作用域末尾时调用\ndisplay println!时的样式\ndebug 同display 用于debug\neq equality for two objects of the same type\npartialord instances比大小"},"IAD":{"title":"IAD","links":[],"tags":[],"content":"无监督方法\n训练集都是正常样本，测试集含有异常样本\n检测 out of distribution\n两种方法feature embedding和reconstructed based\nfeature embedding中用到的方法好像比较多是teacher student\n还不太懂"},"Obsidian":{"title":"Obsidian","links":["动态规划","简历"],"tags":["学习"],"content":"别名\nTransclude of 简历#^9092da\nTransclude of 动态规划#二维费用背包\n\n\n                  \n                  啦啦啦 \n                  \n                \n如果\n其实\n"},"OpenGL":{"title":"OpenGL","links":[],"tags":[],"content":""},"c":{"title":"c","links":[],"tags":["编程语言"],"content":"表达式 §\n表达式语句是表达式后加;\n如hour * 60 + minute;\n表达式有值和类型两个基本属性。 等号运算符的计算结果是左边的值。多个等号从右到左计算。\n如果一个操作数左右两侧各有一个相同优先级的运算符，这个操作数的结合取决于运算符的结合性，相同优先级的运算符的结合性相同。\na=b=c 合法 而(a=b)=c (a=b)不是左值 不合法\n函数调用是一种表达式，()运算符是后缀运算符，函数名是操作数，()及其中参数是操作数的后缀\n使用math.h加-lm\necho $?可以查看上一条命令的退出状态(return 0)\n调用未声明的函数，编译器猜测类型，猜测返回值为int\n调用函数时若参数列表为空，且缺乏函数原型，则编译器认为参数类型是void\n声明函数时若参数列表为空，属于Old Style C，编译器认为参数类型和个数没有明确指定\n//不允许嵌套定义函数\n声明也是以;号结尾，这一点和语句类似，但是在语法上声明和语句是有区别的\nswitch错误\ncase 1: int i = 10;\n \nswitch(n) {\n\tint i = 10;//i未初始化\n\tcase 1:\n\t//...\n}\nmemberwise initialization 多维数组 或者结构体数组嵌套同理\nstruct complex z1 = {.y = 4.0};//z1.x=0.0 z1.y=4.0\nint count[4]= {[2] = 3};\n枚举类型的成员名和变量名在同一空间，而结构体不在。\n数组不能相互赋值，也就不能用作函数参数或返回值，但数组类型作右值时，会自动转换成指向数组首元素的指针。\n字符串字面量的字符可以用下标访问但不能修改，字符串字面量作右值使用时也自动转换成指针\nchar c = &quot;Hello, world&quot;[1];\nc语言存储数组，一行一行拼成一串，row major\nint a[3][2] = {1,2,3,4,5};\n-g选项生成文件才可以调试\ngcc -g main.c -o main\ngdb main\n \nlist //查看源代码\nstart //开始\nnext //一句句执行\nstep //进入\nbacktrace //查看栈帧\ninfo local //查看变量\nframe //选择栈帧\nprint 表达式//打印表达式的值\nfinish //运行到返回\nset var 变量=xxx //\ndisplay //跟踪显示变量\nbreak //设置断点\ncontinue //运行到断点为止\ninfo breakpoints\n \nbreak 9 if sum != 0\nrun\n异或应用 §\n从异或的真值表可以看出，不管是0还是1，和0做异或保持原值不变，和1做异或得到原值的相反值。可以利用这个特性配合掩码实现某些位的翻转\n如果a 1 ^a 2 ^a 3 ^…^a n 的结果是1，则表示a 1 、a 2 、a 3 …a n 之中1的个数为奇数个，否则为偶数个。可用于奇偶校验\n由于x^x=0 x^x^y=y 可用于交换变量\n//不适用于a=b\n*a = *a ^ *b;\n*b = *b ^ *a;\n*a = *a ^ *b;\nsizeof §\nsizeof是一个很特殊的运算符，它有两种形式：“sizeof 表达式”和“sizeof(类型名)”。\n“sizeof 表达式”中的表达式不求值，只推断类型。编译时就能得到\nint a[12];\nprintf(&quot;%u\\n&quot;, sizeof a/sizeof a[0]); //48/4\n返回值类型为size_t，定义在stddef.h头文件中，是一种无符号整型\ntypedef §\ntypedef char array_t[10];\narray_t a;"},"cpp":{"title":"cpp","links":["tags/define","tags/if","tags/endif删除代码块","tags/undef取消定义"],"tags":["编程语言","define","if","endif删除代码块","undef取消定义"],"content":"stream §\ncin buffer不为空时 跳过开始的空白符号\nFail/EOF/Good/Bad\ncin fail导致后续所有操作都fail\ngetline(cin,string,‘\\n’)不跳过开始的空白符号,读到\\n，不将其读入并且之后的读入跳过他\n解决方法cin.ignore()忽略一个buffer中的字符\nint getInteger(const string&amp; prompt,const string&amp; reprompt){\n\twhile (true){\n\t\tcout &lt;&lt; prompt;\n\t\tstring line;\n\t\tif(!getline(cin, line)) throw domain_error(&quot;..&quot;);\n\t\tistringstream iss(line);\n\t\tint val;char remain;\n\t\tif(iss &gt;&gt; val&amp;&amp;!(iss &gt;&gt; remain)) return val;\n        //not fail&amp;&amp;EOF\n\t\tcout&lt;&lt;reprompt&lt;&lt;endl;\n\t}\n\treturn 0;\n}\n将cin的异常状态和剩余内容清除\ncin.clear()\ncin.ignore(numeric_limits&lt;streamsize&gt;::max(),‘\\n’);\nwhile(true){\n\tint x;\n    double y;\n    input&gt;&gt;x&gt;&gt;y;\n    if(input.fail()) break;\n    //处理数据\n}\n \nwhile(input&gt;&gt;x&gt;&gt;y)\n//同理getline\nwhile(getline(cin,str))\n \nwhile(!input.fail())//不好 会多处理一组垃圾数据\nscanf ：读取非char时跳过开始空白符，空白符留在缓冲区\ngets：可接受回车键之前输入的所有字符，回车键不会留在输入缓冲区中\nstream manipulators endl setw() setfill()\nstream随机访问 seekg tellg seekp tellp\n多文件编译 预处理 §\n预处理 编译 链接\n预处理涉及#include 特殊标记#define 宏\n编译 语法错误（分号 未定义变量 参数传入错误）\n链接 建立原型但没有定义的函数\n\n顶部抽象问题依赖于三个子问题，子问题又依赖于更多子问题，顶部不需要知道网络模块如何工作，只需要知道如何使用它\n建立file.h时通常 File_Included命名无实际意义\n#ifndef File_Included\n#define File_Included\n//程序的原型\n#endif\n对应的cpp文件#include “file.h”\n#define 通过第一个空白字符的位置决定替换内容 添加括号保证表达式出现优先级问题\n#if #elif #else #endif只能使用常量 整数值和对应的逻辑算术表达式\ndefined(MY_CONSTANT)与#ifdef相同\n#if 0#endif删除代码块\nmacro\n#define macroname(parameter1, parameter2, ..., parameterN) macro-body \n与C++函数不同，预处理器宏没有返回值，宏的 “返回值 “是它所创建的表达式的结果\ninline functions效率比正常的函数要高 无需处理调用\n可以将函数标记为inline来建议编译器inline它们\n__DATE__ __TIME__ __LINE__ __FILE__\n预处理器的字符串化操作符#\n#define PRINTOUT(n) cout &lt;&lt; #n &lt;&lt; &quot; has value &quot; &lt;&lt; (n) &lt;&lt; endl\nint x = 137;\nPRINTOUT(x * 42);\n//等价于\ncout&lt;&lt;&quot;x * 42&quot;&lt;&lt;&quot; has value &quot;&lt;&lt;(x * 42)&lt;&lt;endl;\n保留变量名 可用于编写诊断函数\n字符串连接操作符##\n#define DECLARE_MY_VAR(type) type my_##type\nDECLARE_MY_VAR(int);\n//等价于\nint my_int;\n#undef取消定义\nX Macro技巧\n//color.h\nDEFINE_COLOR(Red, Cyan)\nDEFINE_COLOR(Cyan, Red)\nDEFINE_COLOR(Green, Magenta)\nDEFINE_COLOR(Magenta, Green)\nDEFINE_COLOR(Blue, Yellow)\nDEFINE_COLOR(Yellow, Blue)\nenum Color {\n    #define DEFINE_COLOR(color, opposite) color, \n    #include &quot;color.h&quot;\n    #undef DEFINE_COLOR\n};\nstring ColorToString(Color c) {\n    switch(c) {\n        #define DEFINE_COLOR(color, opposite) case color: return #color;\n        #include &quot;color.h&quot;\n        #undef DEFINE_COLOR\n        default: return &quot;&lt;unknown&gt;&quot;;\n    }\n}\nColor GetOppositeColor(Color c) {\n    switch(c) {\n        #define DEFINE_COLOR(color, opposite) case color: return opposite;\n        #include &quot;color.h&quot;\n        #undef DEFINE_COLOR\n        default: return c;\n    }\n}\n在.h保存所有信息，用宏按需要提取\nSTL §\n\nsize_t非负\ndeque适合开头结尾插入删除元素\nmap/set基于大小比较\nunordered基于哈希\niterator container.begin()/end()\nmap的iterator指向pair 其中键为const\nmap.insert返回pair&lt;iterator,bool&gt;,iterator指向插入的键值对或者阻止插入的键值对\nmultiset同一个值的多个副本\nmultimap一个键多个值\nequal_range返回等于某值的跨度pair&lt;iter,iter&gt;\nSTL算法 §\naccumulate(iter,iter,初始值)求和\n_if后缀表明要求传入一个函数如count_if(iter,iter,IsEven)\n_copy后缀表明复制到额外一个迭代器的位置\n_n执行n次\nbidirectional-random access(指针)\ninput *myItr = value和++(cin)\noutput value = *myItr(cout)\nforward *myItr = value 和 value = *myItr 和++myItr (链表)\nbirectional forward所有和—(map,set)\nrandom access +和+=(指针，向量，deque)\n\n要求随机访问：\nsort(iter,iter)\nsort(iter,iter,比较函数)\nrandom_shuffle(iter,iter)\nrotate(iter,iter,iter)顺序是开始，旋转中心，结束\nfind(iter,iter,value)\n容器类有同名成员函数时，优先使用成员函数效率更高，stl算法保证通用性，优化不能最好\nbinary_search(iter,iter,value)\niterator adaptors\n（当运行一个产生数据范围的算法时，你必须确保存在足够的空间来容纳结果。然而，在某些情况下，在你实际运行算法之前，你无法知道将产生多少数据。也就是说，确定你需要多少空间的唯一方法是运行该算法，这可能会导致未定义的行为，因为你没有分配足够的空间。）\n不指向容器中的实际元素\nostream_iterator&lt;int&gt; myItr(cout,” “)\nback_insert_iterator&lt;container&gt;等价于back_inserter(container)\nset_union set_intersection set_difference要求有序(?)\ninserter(container,container.begin())\nistream_iterator&lt;int&gt;(istream)和istream_iterator&lt;int&gt;()\n移除算法\nremove并不会删除 只会覆盖，返回不在修改范围的第一个元素的迭代器\nmyVector.erase(remove(myVector.begin(),myVector.end(),137),myVector.end())删除所有137\nremove_if(iter,iter,比较函数)\nremove_copy将没有被移除的元素复制到另一个容器\ntransform(iter,iter,iter,函数)两个迭代器划定范围，一个迭代器指定目的地\nswap()\nmin_element max_element\nreverse_iterator反向遍历\nequal(iter,iter,iter)两个迭代器划定范围，一个迭代器指定第二个范围的开始\n抽象和类 §\n构造函数 §\n当不定义任何构造函数时且所有成员都有无参构造函数时，c++自动提供无参构造函数，会调用每个成员的无参构造函数\n但是int，float等基础类型，指针类型以及组成的类都不会被初始化（成0）这些类型被称为POD\n可以在类内初始化变量\n同理可以在类成员定义中加上{0}\nint x{};\nvoid *p{};\n//等价于\nint x{0};\nvoid *p{nullptr};\n可以通过下列定义恢复该构造函数\nPig pig() = default;\n（C++11）当（和他的基类）不定义任何构造函数，会自动生成一个参数个数和成员一样的初始化列表构造函数 。只能通过{}或={}来调用。\n这个函数也可以指定部分成员初始化，其余的保持默认。（需要防止未指定的未初始化）\n默认生成拷贝构造函数和=重载\n复制所有成员\n可以通过下列定义禁止\nPig(Pig const &amp;) = delete;//禁止拷贝构造函数\n三五法则\n不允许调用构造函数，但构造函数可以调用私有函数，简化代码\ntemplate &lt;typename FirstType, typename SecondType&gt; struct MyPair {\n    FirstType first;\n    SecondType second;\n};\n \ntemplate &lt;typename FirstType, typename SecondType&gt; class MyPair {\n    public:\n        FirstType getFirst();\n        void setFirst(FirstType newValue);\n        SecondType getSecond();\n        void setSecond(SecondType newValue);\n    \tvoid swap(MyPair&amp; other);//不需要&lt;&gt;\n    private:\n        FirstType first;\n        SecondType second;\n};\n \ntemplate &lt;typename FirstType, typename SecondType&gt;\n\tFirstType MyPair&lt;FirstType,SecondType&gt;::getFirst() {\n    return first;\n}\n模板类通常将定义也放在.h中\ntemplate &lt;typename T&gt; class Stack {\n    public:\n        void push(T value);\n        T pop();\n        size_t size();\n        bool empty();\n        typename deque&lt;T&gt;::iterator begin(); //模板类的迭代器\n        typename deque&lt;T&gt;::iterator end(); \n    private:\n        deque&lt;T&gt; elems;\n};\n类的成员函数后加入const关键字\n常量引用\n指向常量的指针const Type* ptr/const Type* ptr\n常量指针Type* const ptr\nconst_iterator(容器实现中有const overloading 有const和非const的迭代器)\n通常从const函数返回指向常量的指针，防止通过指针修改\n语义上和bitwise上的const\n设计了get函数仅当需要时读入更多的数据来返回，因而不再是const函数，内部实现改变了接口，语义上const但不是bitwise const为了解决这个问题，引入mutable标记数据成员，可以在const函数中修改\nconst-correctness\n从不按值传递，不改变状态的成员函数被标记为const，反之相同，从不被修改的变量标记为const\n初始化器列表\nC++创建对象时先开辟内存，再将调用所有变量的默认构造函数（原始类型保持不变），再调用构造函数，非原始类型被构造了两次，使用初始化器列表代替默认值来初始化\nSimpleClass::SimpleClass():myInt(5),myString(&quot;C++!&quot;),myVector(10){\n//空构造函数\n}\nRationalNumber::RationalNumber(int numerator, int denominator):numerator(numerator),denominator(denominator)\n{\n// 空构造函数\n}\n只在函数原型中指定缺省参数，必须都设定或者都不设定\n可以在构造函数初始化器列表修改常量\n静态数据成员\n与整个类相关的数据成员 使用static关键字声明 再(在相关的.cpp中)定义\n静态成员函数\n如传递给STL算法的比较函数期望两个参数，而一般的成员函数多了一个隐含的this参数\n静态函数只能对参数和他的类的静态数据成员操作\n同样的 只在声明时加上static关键字\n两种调用方式\nwindows1.getRemainingInstances()\nWindow::getRemainingInstances()\nconst函数可以修改静态数据 静态成员函数不能被声明为const\n静态常量\n构造函数\nRationalNumber(int numerator = 0, int denominator = 1);\n \nRationalNumber myNumber = 137;\n//被解释为\nRationalNumber myNumber(137, 1);\n单参数构造函数被解释为转换构造函数，加上explicit关键字防止隐式转换\n操作符重载 §\nclass RationalNumber {\n    public:\n    \tconst RationalNumber operator- (const RationalNumber&amp; rhs) const;\n};\nconst RationalNumber operator- (const RationalNumber&amp; arg);\n返回左值和右值，左值([])应返回非const引用，右值应返回const引用\nchar&amp; operator [] (size_t position);\nconst char&amp; operator [] (size_t position) const;\n \n//复合赋值运算符号都应该返回左值\nVector3D&amp; operator+= (const Vector3D&amp; other);\n注意表达式顺序（+这种运算符通常在类外定义）\n++x返回l值,x++返回r值\nclass MyClass {\n    public:\n        MyClass&amp; operator ++(); // Prefix\n        const MyClass operator ++(int dummy); // Postfix\n};\n//前缀++用+=1实现，后缀++用前缀++实现\nMyClass&amp; MyClass::operator ++() {\n    *this += 1;\n    return *this;\n}\nconst MyClass MyClass::operator ++(int dummy) {\n    MyClass oldValue = *this;\n    ++*this;\n    return oldValue;\n}\n//参数名可省略\n重载关系运算符注意trichotomy和transitivity,a和b之间的关系一定是三个中的一个，且大小关系有传递性\nA&lt;B⇔A&lt;BA&lt;=B⇔!(B&lt;A)A==B⇔!(A&lt;B∣∣B&lt;A)A!=B⇔A&lt;B∣∣B&lt;AA&gt;=B⇔!(A&lt;B)A&gt;B⇔B&lt;A\nbool operator &lt; (const MyClass&amp; other) const;\nfriend关键字\n//和模板一起使用时\ntemplate &lt;typename T&gt; class PQueue {\n    public:\n    \ttemplate &lt;typename T&gt; friend PQueueFriend(const PQueue&lt;T&gt;&amp; pq);\n};\nostream&amp; operator &lt;&lt; (ostream&amp; stream, const MyClass&amp; mc) {\n    return stream;\n}\n//还没有完全适配，如setw\nT&amp; operator *() const;\n-&gt;是单目运算符\nCustomStringPointer myCustomPointer;\ncout &lt;&lt; myCustomPointer-&gt;length() &lt;&lt; endl;\n//等同于\ncout &lt;&lt; (myCustomPointer.operator -&gt;())-&gt;length() &lt;&lt; endl;\ntypedef typename vector&lt;T&gt;::iterator iterator;\ntypedef typename vector&lt;T&gt;::const_iterator const_iterator;\n \ntypedef ElemType* iterator;\ntypedef const ElemType* const_iterator;\n//多重[]实现\ntemplate &lt;typename T&gt; class grid {\n    public:\n        class MutableReference {\n        \tpublic:\n                friend class grid;//grid可以调用私有构造函数\n                T&amp; operator[] (size_t col);\n            private:\n                MutableReference(grid* owner, size_t row);\n                grid* const owner;\n                const size_t row;\n\t\t};\n        class ImmutableReference {\n            public:\n                friend class grid;\n                const T&amp; operator[] (size_t col) const;\n            private:\n                ImmutableReference(const grid* owner, size_t row);\n                const grid* const owner;\n                const size_t row;\n        };\n        ImmutableReference operator[] (size_t row) const;\t\n        MutableReference operator[] (int row);\n};\ntemplate &lt;typename T&gt; grid&lt;T&gt;::MutableReference::MutableReference(grid* owner, int row):owner(owner), row(row) {\n}\ntemplate &lt;typename T&gt; T&amp; grid&lt;T&gt;::MutableReference::operator[] (int col) {\n\treturn owner-&gt;getAt(row, col);\n}\ntemplate &lt;typename T&gt; typename grid&lt;T&gt;::MutableReference grid&lt;T&gt;::operator[] (int row) {\n\treturn MutableReference(this, row);\n}\n资源管理 §\n以下三种情况是初始化\n1.初始化变量\nMyClass one;\nMyClass two = one;//等同于\nMyClass two(one);\n2.函数传值\n3.函数返回值\n初始化只是拷贝，赋值涉及到清理现有资源再拷贝\nMyClass(const MyClass&amp; other); //复制构造函数\nMyClass&amp; operator = (const MyClass&amp; other); // 赋值运算符\n类可以访问同一个类的实例的私有数据\n赋值运算符要防止自己赋值给自己的情况\nMyClass::MyClass() : /* Fill in initializer list. */ {\n\t/* Default initialization here. */\n}\nMyClass::MyClass(const MyClass&amp; other) {\n\tcopyOther(other);\n}\nMyClass&amp; MyClass::operator =(const MyClass&amp; other) {\n    if(this != &amp;other) {\n        clear();\n        copyOther(other);\n\t}\n    return *this;\n}\nMyClass::~MyClass() {\n    clear();\n}\nstd:move\nreturn会触发移动\nFunctor §\n类 重载()运算符\ninclude &quot;&quot;优先在当前目录寻找\nuniform initialization大括号\nconst double kWaitTime = 0.1; // 帧之间暂停0.1秒 \n \nvoid Pause() {\n    clock_t startTime = clock();\n    while(static_cast&lt;double&gt;(clock() - startTime)/ CLOCKS_PER_SEC &lt; kWaitTime）\n}\nsrand()随机数种子设定\nsrand(static_cast&lt;unsigned int&gt;(time(NULL)))\n//给出probability概率的真值 rand()∈[0,RAND_MAX]\nbool RandomChance(double probability) {\n\treturn (rand() / (RAND_MAX + 1.0)) &lt; probability;\n}\nauto和decltype()\ntemplate &lt;typename T&gt;\nauto MyFunction(const T&amp; val) -&gt; decltype(val.doSomething()) {\n\treturn val.doSomething();\n}\n复制语义和移动语义\n复制会复制数据，移动不会产生拷贝\nrvalue引用 Type &amp;&amp;\n//移动构造函数\ntemplate &lt;typename T&gt; vector&lt;T&gt;::vector(vector&amp;&amp; other) {\n    elems = other.elems;\n    len = other.len;\n    other.elems = nullptr;\n    other.len = 0;\n}\ntemplate &lt;typename T&gt; vector&lt;T&gt;&amp; vector&lt;T&gt;::operator= (vector&amp;&amp; other) {\n    if(this != &amp;other) {\n        delete [] elems;\n        elems = other.elems;\n        len = other.len;\n        other.elems = nullptr;\n        other.len = 0;\n    }\n    return *this;\n}\nlamda函数\nauto func = [capture-clause](parameters)-&gt;return-value{\n\t//body\n};\ncapture-clause中的参数可以被lamada访问\n(1)[]:没有任何函数参数对象\n(2)[=]:以值传递方式捕获Lambda所在范围内的所有局部变量。\n(3)[&amp;]:以引用传递方法捕获Lambda所在范围内的所有局部变量。\n(4)this:函数体可以使用Lambda所在类的成员变量。\n(5)[x,&amp;y]:x以值传递捕获，y以引用形式捕获。\n(6)[=,&amp;z]:z以引用形式捕获，其他变量以值传递捕获。\n(7)[&amp;,x]:x以值传递形式捕获，其他变量以引用形式捕获。\n括号内加逗号的表达式规则是从左往右执行语句，返回最后一个语句的结果。\n继承 §\nC++接口\nvirtual grid&lt;pixelT&gt; convertToPixelArray() const = 0;\n包含纯虚拟函数的类称为抽象类，不可实例化\n没有被标记virtual的函数不会被取代\n将基类的析构器标记为纯虚拟，但仍需要提供一个什么都不做的实现 先调用派生类的析构器再调用基类的析构器\n完全限定名称的方法\n可以使用初始化器列表（？）来指定派生类调用直接基类的构造函数\n构造函数内的虚函数不会被多态地调用防止访问未初始化的派生类数据\n/* Copy constructor. */\nDerived::Derived(const Derived &amp;other) : Base(other) // Correct\n{\n\tcopyOther(other);\n}\n \n/* Assignment operator. */\nDerived&amp; Derived::operator= (const Derived &amp;other)\n{\n    if(this != &amp;other)\n    {\n        clear();\n        Base::operator= (other); // Invoke the assignment operator from Base.\n        copyOther(other);\n    }\n    return *this;\n}\n私有继承class Derived:private Base将所有公共函数成为私有的，且不能用基类的指针指向它\n安全转换 （隐式）不安全转换（窄化转换）\nC++11引入初始化避免窄化转换 ()圆括号不能防止窄化\ndouble x {2.7};\nint y {x};//错误\n尽可能使用constexpr而不是字面常量（戏称为magic number）\n编译时未知但在初始化后不改变的值用const\nswitch只能使用整型，字符型或枚举类型 case只能是常量表达式 不能重复 可以一个case使用多个常量 在每个case后加break防止无条件执行所有匹配之后的\n!cin catch(…)\n类声明结束要有分号\nC标准库 §\nc中标准库文件在c++中仍然存在，有以下两个版本\n1.推荐使用 无.h后缀 有c前缀 都在命名空间std下 如cstdio\n2.有.h后缀 不使用命名空间\n嵌套命名空间 §\nnamespace MyLibraries::Networking::FTP{}\n \nnamespace MyLibraries{\n\tnamespace Networking{...}\n}\n命名空间别名 §\nnamespace MyFTP = MyLibraries::Networking::FTP\n零初始化 §\n{0}或{}\n新式的枚举 §\nenum class PieceType { King, Queen, Rook, Pawn};\nPieceType piece { PieceType::King };\n可以使用using来避免写全名\n和旧式的命名空间不同\nif/switch语句初始化器 §\nif (&lt;initializer&gt;; &lt;conditional_expression&gt;)\nswitch (&lt;initializer&gt;; &lt;conditional_expression&gt;)\ninitializer的变量只在整个很大的if/switch内有效\n__func__当前函数名称\n双 方括号\nstd::optional\n结构化绑定 §\narray values { 11, 22, 33};\nauto [x, y, z] { values };\n必须auto\n重写方法后加入override关键字\nC++语法的课程文档"},"csapp":{"title":"csapp","links":["c"],"tags":[],"content":"信息的表示和处理 §\n整数的运算满足乘法结合律和交换律，溢出的结果是一致的\n而浮点运算不满足结合律\n(3.14+1e20)-1e20=0.0\n3.14+(1e20-1e20)=3.14\n虚拟地址空间 字节数组\n十进制下x=2^n n=i+4j i∈[0,3]\n该数的十六进制表示为1(i=0) 2(i=1) 4(i=2) 8(i=3)后j个0\n2048=0x800\n字长w 虚拟地址的范围是0-2^w-1\n数据通路的宽度（CPU内部总线的宽度，运算器的位数，通用寄存器的宽度都应该等于）\n字没有什么意义好像 可能是16位\n大端法 最高有效字节在最前面 （正常书写数字规则）\n小端法 最低有效字节在最前面\n较新的微处理器采用双端法两种都能处理\nTransclude of c#异或应用\n练习题2.13\nbis(x,m)=x|m bic(x,m)=x&amp;!m\n移位运算 §\n左移在后面补0 位移量应该是0~w-1 移位运算是可左结合\n逻辑右移 高位补0\n算术右移 在左边补k个最高有效位的值\n所有编译器几乎都对有符号数进行算术右移，而无符号数必须是逻辑的\n移动k位 当k超过w时 移位k mod w\n加减法运算优先级高于移位运算\n补码编码 §\n由位级表示计算真值\nB2Tw​(x)=˙−xw−1​2w−1+i=0∑w−2​xi​2i\nn位补码机器数与真值关系\n[X]补​=2n+X(−2n≤X&lt;2n,mod2n)\n其中[X]补是机器数，X是真值\n对于定点小数，模为2\n补码转无符号 §\nT2Uw​(x)={   x+2w    x ​x&lt;0x&gt;=0​​\n无符号转补码 §\nTMaxw为w位下最大有符号补码数\nUw​2T(u)={   u    u−2w ​u&lt;=TMaxw​u&gt;TMaxw​​​\nC语言中默认为有符号，为了创建无符号常量需要加上后缀字符U或u\n在运算中同时含有有符号和无符号时，会转为无符号的\n\n与负号没啥关系\n位表示扩展 §\n补码在高位填充最高有效位\nshort转为unsigned时等价于(unsinged)(int)short\n数值截断 §\n好像就是直接截断\nB2Uk​(x)=B2Uw​(x)mod2k\nB2Tk​(x)=U2Tk​(B2Uw​(x)mod2k)\n整数运算 §\n2个w位的数之和最大需要w+1位来表示，被称为字节膨胀(lisp支持)\n无符号加法 §\n结果被直接截断\n检测溢出的方法：比结果是否大于加数\nx+wu​y={   x+y    x+y−2w ​x+y&lt;2w2w&lt;=x+y&lt;2w+1​正常溢出​​\n无符号数的加法逆元 §\n在无符号加法中，0是单位元，每个元素都有加法逆元\n−wu​x={   x    2w−x ​x=0x&gt;0​​\n补码加法 §\nx+wt​y=⎩⎨⎧​   x+y−2w    x+y    x+y+2w​2w−1&lt;=x+y−2w−1&lt;=x+y&lt;2w−1x+y&lt;−2w−1​正溢出正常负溢出​​\n补码的加法逆元 §\n除了TMinw的逆元为自身，其余数x的逆元都为-x\n乘法\n无符号与有符号的乘法的结果的位级表示相同，但只看结果（n位乘n位应是2n位 被截断到n位）不能判断是否发生溢出\n计算补码的非 §\n取反+1\n0xf的补（反）是0x0 如0xa的补（反）是0x5 故0xfffffffa是6的补码非 即-6的补码表示\n形如Xw-1,Xw-2,…Xk+1,Xk=1,0,0,0…的数，其补码非为Xw-1到Xk+1取反，后面的10…0不变，如1100（-4）和0100（4），0101（5）和1011（-5）\n舍入 §\n向偶数舍入：如果在某两个数中间，则舍入到偶数(0)，否则根据大小向上或向下\n条件分支 §\nif(test-expr)\n\tthen-statement\nelse\n\telse-statement\n \n//equal to\n\tt = test-statement\n\tif(!t)\n\t\tgoto false;\n\tthen-statement\n\tgoto done;\nfalse:\n\telse-statement\ndone:\n并不一定等价\nv = test-statement ? then-expr : else-expr\n//equal to\nv = then-expr;\nve = else-expr;\nt = test-expr;\nif(!t) v = ve;\ndo\n\tbody-statement\n\twhile (test-expr);\n//equal to\nloop:\n\tbody-statement\n\tt = test-expr;\n\tif(t)\n\t\tgoto loop;\nwhile (test-expr)\n\tbody-statement\n//ver 1 jump to middle\n\tgoto test;\nloop:\n\tbody-statement\ntest:\n\tt = test-expr;\n\tif (t)\n\t\tgoto loop;\n//ver 2 guarded do\n\tt = test-expr;\n\tif(!t)\n\t\tgoto done;\nloop://do-while\n\tbody-statement\n\tt = test-expr;\n\tif (t)\n\t\tgoto loop;\ndone:\nfor (init-expr; test-expr; update-expr)\n\tbody-statement\n//ver 1\n\tinit-expr;\n\tgoto test;\nloop:\n\tbody-statement\n\tupdate-expr;\ntest:\n\tt = test-expr;\n\tif (t)\n\t\tgoto loop;\n//ver 2\n\tinit-expr;\n\tt = test-expr;\n\tif(!t)\n\t\tgoto done;\nloop://do-while\n\tbody-statement\n\tupdate-expr;\n\tt = test-expr;\n\tif (t)\n\t\tgoto loop;\ndone:\n \n过程调用 §\n传递控制 调用时设置PC为被调用函数的起始地址，返回时设置为调用函数的地址\n传递数据\n分配和释放内存\n运行时栈\n\n局部数据存放在内存中的情况\n1.最多在寄存器上传递6个整数值，超过的就放在栈帧中\n2.局部变量为数组或结构\n3.对局部变量使用了地址运算符，因此必须要能寻址他\n寄存器使用惯例\n被调用者保存寄存器(%rbx %rbp %r12-15)，被调用函数要保证寄存器的值在返回时与他被调用时保持一致\n调用者保存寄存器(除栈指针)\n数据对齐\n保证某种类型的数据的地址必须是K的倍数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nK类型1char2short4int,float8long,double,char*\n指针强制类型转换的效果是改变指针运算的伸缩\nchar *p的值为q\n(int *)p+7 = q+28 (int *)(p+7) = q+7\n对抗缓冲区溢出攻击\n栈随机化\n攻击者插入攻击代码需要知道插入代码存放的栈地址\n使得程序运行的栈位置变化 在每次程序运行前在栈上随机分配空间。\nnop sled 在攻击代码前插入很长一段nop，只要猜中序列中的某个地址就能到达攻击代码\n栈破坏检测\n在栈帧中存储canary值，返回时检测是否发生改变"},"csharp":{"title":"csharp","links":[],"tags":["编程语言"],"content":"char[] allMagics = new char[9];\nchar[] allMagics = new char[9]{.....};\n \nint[,] cells = {{1,0,2},{1,2,0},{1,2,1}};\nint[,] squareCrystal = new int[2, 3];\nint[,,] cubeCrystal = new int[2, 3, 4];\nsquareCrystal[0, 2] = 5;\n \nfloat[][] crossCrystal = new float[3][];\ncrossCrystal[0] = new float[3];\ncrossCrystal[1] = new float[4];\nint[][] cells = {new int[]{1,0,2,0},\n\t\t\t\t new int[]{1,2,0},\n\t\t\t\t new int[]{1,2},\n\t\t\t\t new int[]{1}};\ncells[1][0] = 1;\n \nstring[] languages = {&quot;C#&quot;,&quot;COBOL&quot;,&quot;JAVA&quot;,&quot;C++&quot;};\n \nstring[] languages;\nlanguages = new string[]{&quot;C#&quot;,&quot;COBOL&quot;,&quot;JAVA&quot;,&quot;C++&quot;};\nSystem.Array.Sort(array)\nSystem.Array.BinarySearch(array,target)\nSystem.Array.Reverse(array)\nSystem.ArrayClear(array,start index,length)将一块区域设置为默认值\nbool[,,] cells = new bool[2,3,3];\ncells.GetLength(0);//长度 2\ncells.Rank//维度 3\n字符串，支持+拼接其他类型\n字符串前使用@，表明转义序列不被处理，并且能逐字解释所有空白字符。\n字符串前使用，并将表达式嵌入大括号中也可以在前使用@\nstring转换成其他类型\nstring text = &quot;9.11E-31&quot;;\nfloat kgElectronmass = float.Parse(text);\n其他类型转换成string\nbool isMiddle = true;\nstring text = isMiddle.ToString();\nSystem.Convert类型转换\nenum Gender{\n\tMale, Female, Other\n}\nGender gender = Gender.Female;\nstruct中默认private，可以在结构体里定义方法\nstruct是值类型\n原始类型和引用类型\n引用类型按值传递和引用传递\n引用传递可以修改引用类型本身（指针？）指向的地址，按值传递只能读取地址修改堆上的内容\n标识符 §\n字母 下划线\n数字不能在首位\n@只能首位\n格式字符串 §\nWrite和Writeline中使用\nConsole.WriteLine(&quot;Two sample integers are {0} and {1}.&quot;, 3, 6);\n{0}称为替代标记 值可以被多次使用\n引用出界发生运行时错误\n{index, alignment:format}\nalignment左右对齐\nformat格式字段 由格式说明符和精度说明符组成\n字符串插值 §\nC#6.0\nConsole.WriteLine($&quot;Two sample integers are {var1} and {var2}.&quot;);\n数值类型不具有布尔意义\n类声明结束无分号\n字段初始化 §\nclass MyClass{\n\tint F1;//使用默认值\n\tint F2 = 25;//使用初始化值\n}\n初始化值编译时需能确定\n为类对象数据分配内存 §\nnew TypeName()\n类成员默认private\n局部常量必须初始化，初始化值能编译时决定\nC#7.0可以在一个函数内声明另一个函数，只能在该方法内调用\n值参数 §\n在栈中为形参分配空间，复制实参的值给形参\n引用参数 §\n在调用中也要使用ref修饰，实参必须是变量，在用作实参前被赋值\n不分配内存，起别名\n输出参数 §\n在调用中也要使用out修饰，实参必须是变量\n不分配内存，起别名\n方法内部需先给其赋值才能访问它\n返回前必须赋值\nC#7.0不需要预先声明变量作out参数\n参数数组 §\n只能有一个参数数组，必须在最后\n声明 §\nvoid ListInts( params int[] inVals )\n调用 §\nListInts( 10, 20 ,30 );\n \nint[] intArray = {1, 2, 3};\nListInts( intArray );\n如果没有实参，创建零个或一个元素的数组\n别名 §\nref int y = ref x;\nref int RefToValue(){\n\treturn ref Score;\n}\nref int x = ref xxx.RefToValue();\n要求ref return不能返回空值，常量，枚举成员，类或结构体的属性，指向只读位置的指针\n只能返回原先调用域中的\nref局部变量只能被赋值一次\n命名参数 §\nint Calc(int a, int b, int c){}\nxxx.Calc(c:2, a:4, b:3);\n与位置参数同时使用时，位置参数必须全部出现在前\n可选参数 §\n默认值必须在编译时确定，引用类型null\n顺序必须依次为必填参数，可选参数，params参数\n省略不能任意组合，只能省略最后n个参数\n如果要任意省略，需要使用命名参数\nconst\n必须初始化且编译时确定\n成员常量\n编译时被替换 没有存储位置\n没有类实例也能访问 不能声明为static\n属性 §\n \n属性本身没有存储什么，set访问器有一个隐式值参value\n不能显式调用属性\n属性是函数成员\n可以声明为static\n自动实现属性 §\npublic int MyValue{\n\tset;get;\n}\n静态构造函数\n只能有一个 不能带有参数 不能有访问修饰符 自动调用\n对象初始化语句\nnew TypeName {};\nnew TypeName() {};//先构造函数\n初始化的值必须是public的\nreadonly\n修饰字段 类似const 但不需要在声明时初始化 不需要编译时决定"},"git":{"title":"git","links":[],"tags":[],"content":"cd想要创建仓库的位置\ngit init\ngit add &lt;file&gt;\n查看状态\ngit status\n保存 -m可以附加一条信息\ngit commit -m &lt;MESSAGE&gt;\n查看提交记录\ngit log\n查看提交信息 使用提交记录中的id\ngit show &lt;id&gt;\n修改文件后直接commit是无效的（也可以观察到status里面的提示），需要再次将文件add\n回滚 （会自动为其更改的文件执行git add）\ngit checkout &lt;id&gt; &lt;path&gt;\n\nUnstage\ngit reset HEAD &lt;file&gt;\n修改（取代）最新的commit\ngit commit --amend\ngit push origin master\ngit clone [remote-repo-URL]\ngit remote add [remote-repo-name] [remote-repo-URL]\ngit remote -v\ngit pull [remote-repo-name] master\ngit push [remote-repo-name] master"},"index":{"title":"Crypter","links":["操作系统","算法","编译原理","Daily/2023-12-23"],"tags":["example-tag"],"content":"你好\n操作系统\n算法\n编译原理\njyy 可执行文件相关笔记"},"java":{"title":"java","links":[],"tags":["编程语言"],"content":"Walrus a = new Walrus(1000, 8.3);\nstring不属于原始类型（byte, short, int, long, float, double, boolean, char）其余都被称为reference type\n在java中对象的变量是指针 对象声明时开辟64bit空间存储地址 需要用new来为对象的实际内容开辟空间 复制对象即复制指针\n对象并不是引用传递 而是按值传递引用 创建了一个新的指针指向同一块内存，在c中出现的swap指针函数在java中无法达到目的\n原始类型按值传递\npublic class SLList {\n   private static class IntNode {\n      public int item;\n      public IntNode next;\n      public IntNode(int i, IntNode n) {\n         item = i;\n         next = n;\n      }\n   }\n   private IntNode sentinel;\n   private int size;\n   public SLList() {\n      sentinel = new IntNode(-1, null);\n      size = 0;\n   }\n   public SLList(int x) {\n      size = 1;\n      sentinel = new IntNode(-1, null);\n      sentinel.next = new IntNode(x, null);\n   }\n   public void addFirst(int x) {\n      size += 1; \n      sentinel.next = new IntNode(x, sentinel.next);\n   }\n   public void addLast(int x) {\n      size += 1;\n      IntNode p = sentinel;\n      while (p.next != null) {\n         p = p.next;\n      }\n \n      p.next = new IntNode(x, null);\n   }\n}\n不需要被外部类访问所以使用private 不需要访问SLList的实例 所以使用static\npublic class SLList&lt;BleepBlorp&gt;{...}\nDLList&lt;Double&gt; s1 = new DLList&lt;&gt;(5.3);\nfinal §\n对于变量，表示其不会再变成引用别的变量，但是引用的对象内容可以修改\n对于类，表示其不能被继承\n对于方法，表示不能被覆盖\n返回对象\n返回可变对象的引用，应该先克隆 return (Date) hireDay.clone();\n显式字段初始化 §\n可以直接在类定义中为字段赋值\nclass Employee{\n\tprivate static int nextId;\n\tprivate int id = assignId();\n\tprivate static int assignId(){\n\t\tint r = nextId;\n\t\tnextId++;\n\t\treturn r;\n\t}\n}\nthis/super §\n构造函数中调用其他构造函数 必须在最前面\n表示该对象或父类\n静态导入 §\nimport static java.lang.System.*\n不止导入所有类，还导入静态方法和字段（可以省略System.out中的System）\n数组类型转换 §\nManager[] managers = new Manager[10];\nEmployee[] staff = managers; // ok\nstaff[0] = new Employee();\nmanagers[0].setBonus() //???\nGeneric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n原始类型引用类型intIntegerdoubleDoublecharCharacterbooleanBooleanlongLongbyteByteshortShortfloatFloat\nArray 引用\nint[] x = new int[3];\nint[] y = new int[]{1, 2, 3, 4, 5};\nint[] z = {9, 10, 11, 12, 13};\nint l = z.length;\nSystem.arraycopy(b, 0, x, 3, 2);\n原array，原array的复制起始位置，目标array，目标array的黏贴起始位置，复制数量\nint[][] pascalsTriangle = new int[4][];\npascalsTriangle[0] = new int[]{1};\npascalsTriangle[1] = new int[]{1, 1};\npascalsTriangle[2] = new int[]{1, 2, 1};\npascalsTriangle[3] = new int[]{1, 3, 3, 1};\nint[] rowTwo = pascalsTriangle[2];\nrowTwo[1] = -5;\n \nint[][] matrix;\nmatrix = new int[4][];//Create 1 array\nmatrix = new int[4][4];//Create 5 arrays\n \nint[][] pascalAgain = new int[][]{{1}, {1, 1},\n                              \t{1, 2, 1}, {1, 3, 3, 1}};\n \npublic class AList&lt;Glorp&gt; {\n    private Glorp[] items;\n    private int size;\n    public AList() {\n        items = (Glorp []) new Object[8];\n        size = 0;\n    }\n}\n由于泛型数组存储的是对象的引用，要确实地删除对象地引用，保证不loiter 浪费内存\npublic Glorp deleteBack() {\n    Glorp returnItem = getBack();\n    items[size - 1] = null;\n    size -= 1;\n    return returnItem;\n}\nsllist和alist都应属于list，定义接口，接口规定要实现的内容\npublic interface List61B&lt;Item&gt; {\n    void addFirst(Item x);\n    default public void print() {\n        for (int i = 0; i &lt; size(); i += 1) {\n            System.out.print(get(i) + &quot; &quot;);\n        }\n        System.out.println();\n    }\n}\npublic class AList&lt;Item&gt; implements List61B&lt;Item&gt;{...}\ninterface可以存变量，但变量是public static final不能改变\n对于继承方法，函数参数与接口定义完全相同为override，不同为overload\n返回类型override\n允许子类将override方法的返回类型改为原返回类型的子类型\n可选：在override的方法前标注@Override，若方法并不是override则不编译\n上面的print()方法在SLList应当override\n要使类继承另一个类，使用extend关键字\npublic class RotatingSLList&lt;Blorp&gt; extends SLList&lt;Blorp&gt;{\n\tpublic void rotateRight() {\n\t\tBlorp oldBack = removeLast();\n\t\tinsertFront(oldBack);\n\t}\n}\npublic class VengefulSLList&lt;Item&gt; extends SLList&lt;Item&gt; {\n    private SLList&lt;Item&gt; deletedItems;\n    public VengefulSLList() {\n        super();\n    \tdeletedItems = new SLList&lt;Item&gt;();\n    }\n    @Override\n    public Item removeLast() {\n        Item oldBack = super.removeLast();\n        deletedItems.addLast(oldBack);\n        return oldBack;\n    }\n    public void printLostItems() {\n    \tdeletedItems.print();\n    }\n}\njava中 变量是静态绑定的，方法（除static）是静态绑定的\njava中有变量同时拥有有动态类型和静态类型，静态类型不能改变，是声明时的类型，动态类型可以在赋值中改变。\nfoo.bar(x1)编译器会记录foo的静态类型对x1的静态类型的对应函数。如果foo的动态类型overridebar方法，会执行动态类型对应的，否则执行记录的。\n编译器类型检查根据静态类型，将父类赋给子类等行为会导致编译失败\n判断赋值能不能通过编译，可以通过判断是否满足右边is a左边\n强制类型转换 §\nif (staff instanceof Manager){\n\tboss = (Manager) staff;\n}\nString C = (String) staff;\n在继承链自下而上强制转换时会产生ClassCastException，如果更加错的离谱的会编译错误\ncast 不会造成改变 只是对编译器的\n抽象类\n可包括抽象方法，字段和具体方法\n抽象方法是没有被实现的\n不能创建抽象类的对象，但是可以有抽象类的对象变量引用到他的具体子类对象\n自定义比较的实现思路\nComparable是内建的类，已经对一些自带的类实现比较\n实现比较的类（如Dog）implements Comparable&lt;Dog&gt;中的compareTo(Dog)方法\n调用方调用继承了Comparable接口的对象\nimport java.util.Comparator;\nComparator实现各种不同标准的比较\n实现比较的类（如Dog）中嵌套类NameComparator（static）implementsComparator&lt;Dog&gt;实现compare(Dog,Dog)方法\n将嵌套类设为private，在类中提供返回comparator的static方法 比较器的类型应由Dog.NameComparator改为Comparator&lt;Dog&gt;\ninterface提供了实现callback的能力，通过implement comparable只能实现一种比较，而comparator的多态能提供多种比较\ncomparable将自己与其他比较，comparator将两种作比较\njava提供Collection类\n\n\npackage\nautoboxing和unboxing\nimmutable没有“可发现的”方法改变，如Integer,String,Date\ngeneric method在返回类型前加&lt;&gt;\n&lt;K extends Comparable&lt;K&gt;&gt;\n程序异常时会从调用栈一层层寻找catch，如果没有则程序crash，会打印调用栈\nchecked异常会使得编译失败\ncatch那些checked异常或在方法后面声明throws xxException\nIterable Iterator\n\naccess control基于static类型\n所有object都有toString()方法\n检查是否指向同一，.equals()默认是\n.getClass()"},"make":{"title":"make","links":[],"tags":[],"content":"&lt;target&gt; : &lt;prerequisites&gt; \n[tab]  &lt;commands&gt;\ntarget可以是文件名代表生成对象，或者是自定义操作名\n.PHONY声明一个名称为伪目标（操作），防止与文件重名\nprerequisites代表依赖关系\n.RECIPEPREFIX可以修改tab标记为别的键\ncommands默认在不同的shell执行（影响export这种）\n解决方法分号分隔命令或者.ONESHELL:\ncommands中的命令会被打印，可以在命令前加@制止"},"python":{"title":"python","links":[],"tags":["编程语言"],"content":"逻辑运算符 §\nx and y 如果 x 为 False，返回 x ，否则返回 y 。\nx or y    如果 x 是 True，返回 x ，否则返回 y 。\n在错误信息中，最近调用的函数在最下方。\n计算嵌套表达式\n计算operator和operend\nlambda表达式\nlambda &lt;parameters&gt;: &lt;return expression&gt;\n先从左到右计算所有表达式，再赋值\nx = 10\ny = x\nx = 20\nx, y = y + 1, x - 1 #x=11 y=19\n先在local frame中找该名字，再在global frame中找\n\nfrom operator import mul\ndef square(square):\n\treturn mul(square, square)\nsquare(-2)\npython -i ex.py //用intepreter运行\npython -m doctest -v ex.py\nprint(print(1), print(2)) //print的返回值是None\n&#039;&#039;&#039;\n1\n2\nNone None\n&#039;&#039;&#039;\npython支持多个返回值\ndocstring, doctest\nfrom operator import floordiv, mod\ndef divide_exact(n, d):\n\t&quot;&quot;&quot;Return the quotient and remainder of dividing N by D.\n\t&gt;&gt;&gt;q, r = divide_exact(2013, 10)\n\t&gt;&gt;&gt;q\n\t201\n\t&gt;&gt;&gt;r\n\t2\n\t&quot;&quot;&quot;\n\treturn floordiv(n, d), mod(n, d)\nquotient, remainder = divide_exact(2013, 10)\n \nassert 2 &gt; 3, &#039;That is false&#039;\n环境 嵌套\n\n当函数被定义时：\n创建一个function value: func &lt;name&gt;(&lt;formal parameters&gt;) [parent=&lt;parents&gt;] Its parent is the current frame. Bind to the function value in the current frame\n当函数被调用时：\n\nAdd a local frame, titled with the &lt;name&gt; of the function being called.\nCopy the parent of the function to the local frame: [parent=&lt;label&gt;]\nBind the &lt;formal parameters&gt; to the arguments in the local frame.\nExecute the body of the function in the environment that starts with the local frame\n\nlambda的parent是它所在的frame\n装饰器 §\nfrom ucb import trace\n \n@trace\ndef fib(n): \ndef zero(f):\n    return lambda x: x\n \n \ndef successor(n):\n    return lambda f: lambda x: f(n(f)(x))\n \ndef one(f):\n    return lambda x: f(x)\n \ndef two(f):\n    return lambda x: f(f(x))\n \ndef church_to_int(n):\n    &quot;&quot;&quot;Convert the Church numeral n to a Python integer.\n \n    &gt;&gt;&gt; church_to_int(zero)\n    0\n    &gt;&gt;&gt; church_to_int(one)\n    1\n    &gt;&gt;&gt; church_to_int(two)\n    2\n    &gt;&gt;&gt; church_to_int(three)\n    3\n    &quot;&quot;&quot;\n    return n(lambda x: x + 1)(0)\n \ndef add_church(m, n):\n    &quot;&quot;&quot;Return the Church numeral for m + n, for Church numerals m and n.\n \n    &gt;&gt;&gt; church_to_int(add_church(two, three))\n    5\n    &quot;&quot;&quot;\n    return lambda f: lambda x: n(f)(m(f)(x))\n \n \ndef mul_church(m, n):\n    &quot;&quot;&quot;Return the Church numeral for m * n, for Church numerals m and n.\n \n    &gt;&gt;&gt; four = successor(three)\n    &gt;&gt;&gt; church_to_int(mul_church(two, three))\n    6\n    &gt;&gt;&gt; church_to_int(mul_church(three, four))\n    12\n    &quot;&quot;&quot;\n    return lambda f: m(n(f))\n \n \ndef pow_church(m, n):\n    &quot;&quot;&quot;Return the Church numeral m ** n, for Church numerals m and n.\n \n    &gt;&gt;&gt; church_to_int(pow_church(two, three))\n    8\n    &gt;&gt;&gt; church_to_int(pow_church(three, two))\n    9\n    &quot;&quot;&quot;\n    return n(m)\n递归\n执行顺序\n不重不漏的分解原问题\nList §\ndigits = [1, 8, 2, 8]\ngetitem(digits, 3)\n&gt;&gt;&gt; len(digits)\n4\n&gt;&gt;&gt; [2, 7] + digits * 2\n[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]\n&gt;&gt;&gt; 1 in digits\nTrue\n&gt;&gt;&gt; 5 not in digits\n&gt;&gt;&gt; not(5 in digits)\n&gt;&gt;&gt; [1, 8] in digits #属于关系\nFalse\n \n[&lt;expression&gt; for &lt;element&gt; in &lt;sequence&gt; if &lt;conditional&gt;]\n[x for x in range(10) if 10 % x == 0]\nthe negative index -i is equivalent to the positive index len(lst)-i\nList slicing §\nTo create a copy of part or all of a list, we can use list slicing. The syntax to slice a list lst is: lst[&lt;start index&gt;:&lt;end index&gt;:&lt;step size&gt;].\nThis expression evaluates to a new list containing the elements of lst:\n\nStarting at and including the element at &lt;start index&gt;.\nUp to but not including the element at &lt;end index&gt;.\nWith &lt;step size&gt; as the difference between indices of elements to include.\n\nIf the start, end, or step size are not explicitly specified, Python has default values for them. A negative step size indicates that we are stepping backwards through a list when including elements.\n&gt;&gt;&gt; lst[:3]   # Start index defaults to 0\n[6, 5, 4]\n&gt;&gt;&gt; lst[3:]   # End index defaults to len(lst)\n[3, 2, 1, 0]\n&gt;&gt;&gt; lst[::-1]   # Make a reversed copy of the entire list\n[0, 1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt; lst[::2]  # Skip every other; step size defaults to 1 otherwise\n[6, 4, 2, 0]\nfor §\nfor element in s:\n \npairs = [[1, 2], [2, 2], [3, 2], [4, 4]]\nfor x, y in pairs:\nrange §\n&gt;&gt;&gt; list(range(-2, 2))\n[-2, -1, 0, 1]\n&gt;&gt;&gt; list(range(4))\n[0, 1, 2, 3]\n \nfor i in range(n):\n\n方括号内的内容可省略\nsum(iterable[, start])\nsum([[1, 2],[3, 4]], [])\n \nmax(iterable[,key=func])\nmin(iterable[,key=func])\nall(iterable)\nexec(&#039;curry = lambda f: lambda x: lambda y: f(x, y)&#039;)\ncurry(add)(3)(4)\nString\n单引号和双引号等价\n三引号可以跨行\nstring的元素仍然是string\nDictionary\n{&lt;key exp&gt;:&lt;value exp&gt; for &lt;name&gt; in &lt;iter exp&gt; if &lt;filter exp&gt;}\ntuple\n元组 不可变 用逗号分隔的\n内含可变元素可变\nidentity is\nIdentity is evaluates to True if both and evaluate to the same object Equality ==\nevaluates to True if both and evaluate to equal values Identical objects are always equal values\n函数默认参数为mutable时 不会被类似初始化重新赋值\nSome files are plain text and can be read into Python as either:\nOne string containing the whole contents of the file: open(‘/some/file.txt’).read()\nA list of strings, each containing one line: open(‘/some/file.txt’).readlines()\nUseful string methods for processing the contents of a file:\n.strip() returns a string without whitespace (spaces, tabs, etc.) on the ends\n.split() returns a list of strings that were separated by whitespace\n.replace(a, b) returns a string with all instances of string a replaced by string b\nA container can provide an iterator that provides access to its elements in order\niter(iterable): Return an iterator over the elements of an iterable value\nnext(iterator): Return the next element in an iterator\nlist(t) 所有剩余元素的list\niterator可变\n可以用for遍历\nmap(func, iterable) 返回一个iterator\nfilter(func, iterable)返回下一个为真的func(x)\nzip(first_iter, second_iter)\nreversed(sequence)\nlist/tuple/sorted(iterable)\nThe built-in zip function returns an iterator over co-indexed tuples.\nIf one iterable is longer than the other, zip only iterates over matches and skips extras.\nMore than two iterables can be passed to zip."},"record":{"title":"record","links":[],"tags":[],"content":"粗糙的分为三个部分albedo shading和specular来估计出一个粗的结果，然后refine颜色失真和tone"},"代数系统":{"title":"代数系统","links":["代数系统","集合论"],"tags":["离散数学"],"content":"二元运算 §\n设 S 为集合，函数 f  ： S × S → S 称为 S 上的 二元运算\nS 中任何两个元素都可以进行运算，且运算的结果惟一．\nS 中任何两个元素的运算结果都属于 S ，即 S对该运算封闭．\n一元运算 §\n设 S 为集合，函数 f : S→ S 称为 S 上的 一元运算\n\n交换律 §\n设◦为 S 上的二元运算, 若对任意 x ,y ∈ S 有 x ◦ y = y ◦ x , 则称运算在 S 上满足 交换律.\n结合律 §\n设◦为 S 上的二元运算, 若对任意 x , y , , z ∈ S 有 有 ( x ◦ y )◦ z = x ◦( y ◦ z ), 则称运算在 S 上满足结合律. .\n幂等律 §\n设◦为 S 上的二元运算, 若对任意 x ∈ S 有 x ◦ x = x , 则称运算在S 上满足 幂等律.\n分配律 §\n设◦和∗为 为S 上两个不同的二元运算,\n若对任意x,y,z ∈S有 有 (x∗y)◦z=(x◦z)∗(y◦z)，z◦(x∗y)=(z◦x)∗(z◦y), 则称◦运算对∗运算满足分配律\n吸收律 §\n若°和 和∗都可交换, 且对任意x,y ∈S有 有 x◦(x∗y)=x ，x∗ (x◦y)=x,则称◦和∗运算满足吸收律\n单位元 §\n与单位元运算为自身\n设◦ 为S 上的二元运算,\n(1) 如果存在e l ( 或e r )∈S ，使得对任意 x ∈S 都有\ne l ◦x = x (或 x◦e r = x)，则称e l ( 或e r ) 是S 中关于◦ 运算的左(或右) 单位元.\n若e ∈S 关于◦ 运算既是左单位元又是右单位元，则称e 为S 上关于◦ 运算的 单位元. 单位元也叫做 幺元.\n存在一行和（和一列），该行（列）所有元素等于他所在列的头\n零元 §\n与零元运算为零元\n如果存在 θl (或\n或θr ) ∈S ，使得对任意 x ∈S 都有θl ◦x = θ θ l\n(或x◦ θr= θr)，则称θl (或 θr ) 是S 中关于◦ 运算的左(或右) 零元.\n若 θ ∈S 关于◦ 运算既是左零元又是右零元，则称 θ 为S 上关于运算◦的 零元.\n存在一行和（和一列），该行（列）所有元素该行的头\n可逆元素和逆元 §\n与逆元运算为单位元\n设◦ 为S 上的二元运算 , 令e 为S 中关于运算°的单位元.\n对于x ∈S ，如果存在y l ( 或y r ) ∈S 使得y l ◦x=e （或x◦y r =e）则称y l (或y r ) 是x 的 左逆元 （或 右逆元） ）.关于◦ 运算，若y ∈S 既是 x 的左逆元又是 x 的右逆元，则称y 为x 的 逆元. 如果 x 的逆元存在，就称 x 是可逆的\n设*是A上的二元运算 ， 具有左幺元el ，右幺元er ， 则e e l=e r =e\n单位元，零元，逆元若存在，则唯一\n当 |S| ≥ ≥ 2 ，单位元与零元是不同的；\n当 |S| = 1，这个元素既是单位元也是零元\n消去律 §\n已知 &lt;A ，* &gt;  ，若∀x ，y ， z∈A ，有\n(1) 若  x* y = x* z且x ≠ θ, , 则 y=z ；\n(2) 若 y* x = z* x且 x ≠θ, , 则 y=z ；那么称*满足消去律\n代数系统 §\n非空集合S 和S 上k 个一元或二元运算f 1 ,f 2 ,…, f k 组成的系统称为 代数系统, 简称代数，记做&lt;S, f 1 , f 2 , …, f k &gt;.\n当Ω ={f 1 ,…,f n }是有限时,代数系统常记为&lt;S,f 1 ,…,f n &gt;\n当A有限时,称&lt;A,Ω&gt;是有限代数系统\n同类型 §\n如果两个代数系统中运算的个数相同，对应运算的元数相同，且代数常数的个数也相同，则称它们是 同类型的 代数系统.\n同种 §\n如果两个同类型的代数系统规定的运算性质也相同，则称为 同种的代数系统\n子代数 §\n设V=&lt;S, f 1 , f 2 , …, f k &gt; 是代数系统，B 是S 的非空子集，如果B 对f 1 , f 2 , …, f k 都是封闭的，且B 和S 含有相同的代数常数，则称&lt;B, f 1 , f 2 , …, f k &gt; 是V 的 子代数系统 ，简称子代数. 有时将子代数系统简记为B.\n积代数 §\n设V 1 =&lt;A,◦&gt;和 和V 2 =&lt;B,∗&gt; 是同类型的代数系统，◦ 和∗为二元运算，在集合A× ×B 上如下定义二元运算▪，∀&lt;a 1 ,b 1 &gt;,&lt;a 2 ,b 2 &gt;∈A×B ，有\n&lt;a 1 ,b 1 &gt;▪&lt;a 2 ,b 2 &gt;=&lt;a 1 ◦ a 2 , b 1 ∗b 2 &gt;\n称V=&lt;A×B,▪ &gt; 为V 1 与V 2 的 积代数 ，记作V 1 ×V 2 . 这时也称V 1和V 2 为V 的因子代数\n同态 §\n设V 1 =&lt;A,∘&gt;和 和V 2 =&lt;B,∗&gt; 是同类型的代数系统，f:A →B ，且∀x, y∈A有 有 f(x∘y) = f(x)∗f(y), 则称 f 是V 1 到V 2 的同态 映射，简称同态\n单同态：f为单射\n满同态：f为满射\n同构：f为双射\n若V1=V2则称为自同态\n半群 §\n设V=&lt;S, ∘ &gt; 是代数系统，∘ 为二元运算，如果∘运算是可结合的，则称V为 半群.\n幺半群（独异点） §\n设V=&lt;S,∘ &gt;是半群，若 是半群，若e ∈S是关于 是关于∘ 运算的单位元，则称 运算的单位元，则称V是 含幺半群 ，也叫做 独异点. 有时也将独异点V 记作V=&lt;S,∘,e&gt;.\n群 §\n设V=&lt;S,∘&gt;是幺半群，e∈S关于∘运算的单位元，若∀a∈S ，a−1 ∈ ∈S ，则称V 是群. 通常将群记作G\nKlein四元群\n群的阶 §\n群G 的基数称为群 G 的 阶，有限群G 的阶记作|G|.\n有穷群 §\n群G 是有穷集\n无限群 §\n群G 是无限集\n平凡群 §\n只含单位元（阶数为1 ）的群称为 平凡群\n交换群 §\n若群G 中的二元运算是可交换的，则称G 为 交换群 或 阿贝尔 (Abel) 群.\n元素的幂 §\n设G 是群，a ∈G ，n ∈Z ，则a 的 的 n 次幂\nan=⎩⎨⎧​   e    an−1 (a−1)m​n=0n&gt;0n&lt;0,n=−m​​\n元素的阶 §\n设G 是群，a ∈G ，使得等式 a k =e 成立的最小正整数\nk 称为a 的阶，记作|a|=k ，称 a 为 为 k 阶元. 若不存在这样的正\n整数 k ，则称 a 为无限阶元\n子群 §\n设G 是群，H 是G 的非空子集，\n(1) 如果H 关于G 中的运算构成群，则称H 是G 的 子群, 记作H≤G.\n(2) 若H 是G 的子群，且H⊂G ，则称H 是G 的 真子群 ，记作H&lt;G.\ntodo 求子群 §\n判定定理 §\n设G 为群，H 是G 的非空子集，则H 是G 的子群当且仅当\n(1) ∀ a,b ∈H 有ab ∈H\n(2) ∀ a ∈H 有a − 1 ∈H.\n设G 为群，H 是G 的非空子集. H 是G 的子群当且仅当∀a,b ∈H\n有ab −1 ∈ H.\n设G 为群，H 是G 的非空有穷子集，则H 是G 的子群当且仅当∀a,b ∈H 有ab∈ H.\n平凡子群 §\n对任何群G 都存在子群. G 和{e} 都是G 的子群，称为G 的平凡子群.\n子群格 §\n设G 为群, 令L(G) = {H | H 是G 的子群}，则偏序集&lt; L(G), ⊆ &gt; 称为G 的子群格\n右陪集 §\n设H 是G 的子群，a∈G.令Ha={ha | h ∈H}，称Ha 是子群H 在G 中的 右陪集. 称a 为Ha 的 代表元素\nLagrange定理\n∣G∣=∣H∣∗[G:H]\n[G:H]是H在G中的陪集数\n推论\n循环群/生成元 §\n一个元素的不同幂次能构成整个集合\n设G 是群，若存在a ∈G 使得G={a^k | k ∈Z}，则称G 是 循环群 ，记作G=&lt;a&gt; ，称 a 为G 的生成元.\n循环群的分类：n 阶循环群 和 无限循环群.\n\n环 §\n设&lt;R,+,·&gt; 是代数系统，+ 和· 是二元运算. 如果满足\n以下条件:\n(1) &lt;R,+&gt; 构成 交换群\n(2) &lt;R,·&gt; 构成 半群\n(3) · 运算关于+ 运算适合 分配律\n则称&lt;R,+,·&gt; 是一个环.\n通常称+ 运算为环中的 加法， · 运算为环中的 乘法.\n环中加法单位元记作 0 ，乘法单位元（如果存在）记作1.\n对任何元素 x ，称 x 的加法逆元为 负元 ，记作−x.\n若 x 存在乘法逆元的话，则称之为 逆元 ，记作x ^−1\n交换环 §\n设&lt;R,+,·&gt; 是环，若环中乘法 · 适合交换律，则称R 是 交换环\n含幺环 §\n设&lt;R,+,·&gt; 是环，若环中乘法 · 存在单位元，则称R 是 含幺环\n无零因子环 §\n非零的乘积非零\n设&lt;R,+,·&gt; 是环，若 ∀a,b ∈R， ab=0 ⇒  a=0 ∨b=0 ，则称R 是无零因子环\n整环 §\n设 &lt;R,+,• &gt; 是一个代数系统, 若满足:\n(1) &lt;R,+&gt;是阿贝尔群\n(2) &lt;R,• &gt; 是可交换独异点，且无零因子\n(3) 运算• 对+是可分配的\n则称 &lt;R,+,• &gt;是 整环\n域 §\n设 &lt;R,+,• &gt; 是一个代数系统, 若满足:\n(1) &lt;R,+&gt;是阿贝尔群\n(2) &lt;R-{0},• &gt;是阿贝尔群\n(3) 运算• 对+是可分配的\n则称 &lt;R,+,• &gt;是 域\n格 §\n设 &lt;S, ≼&gt;是偏序集，如果∀ x,y∈S ，{x,y} 都有最小上界和最大下界，则称S关于偏序  ≼作成一个格\n求{x,y} 最小上界和最大下界看成 x 与 与 y 的二元运算 ∨ 和 ∧\n对偶定理 §\n设f 是含有格中元素以及符号 是含有格中元素以及符号 =,≼  ,≽  ,∨  和 ∧ 的命题，令 f* 是将 f 中的 中的≼ 替换成≽,≽ 替换成≼,∨替换成∧, ∧ 替换成∨所得到的命题. 称  f* 为 f 的对偶命题"},"关系代数":{"title":"关系代数","links":[],"tags":[],"content":"域 §\n具有相同数据类型的值的集合\n空值null是所有域的取值\n笛卡尔积 §\n给定域D1,…Dn\nD1​×D2​×...×Dn​={(d1​,d2​,...,dn​)∣di​∈Di​i=1,2,...,n}\n关系 §\n笛卡尔积的子集，表示为r(D1,D2,…Dn)\nn是关系的度/目，单元关系，二元关系"},"分组背包":{"title":"分组背包","links":[],"tags":["算法"],"content":"集合：\n只从前i组物品当中选，且总体积不超过j的情况下的所有选法\n属性：\n所有选法价值的最大值。\n状态计算：\n集合划分为，第i组物品中不选或选了第k个\n从而状态转移方程为：f[i][j] = max(f[i-1][j], f[i-1][j-v[i][k]] + w[i][k])\n三重循环：物品 体积 决策"},"动态规划":{"title":"动态规划","links":["01背包","完全背包","多重背包","分组背包"],"tags":["算法"],"content":"动态规划 §\n拓扑序\n背包问题 §\n01背包 §\n01背包\n完全背包 §\n完全背包\n多重背包 §\n多重背包\n分组背包 §\n分组背包\n二维费用背包 §\n集合：只从前i个物品中选，花费1不超过j，花费2不超过k的选法\n状态计算：f[i][j][k] = max(f[i-1][j][k], f[i-1][j-v1[i]][k-v2[i]] + w[i][k])\n三种不同划分的比较 §\n以选法为例，最大值最小值同理\n集合：恰好是k的选法\nf[0]=1,f[k≠0]不存在，此处为0\n集合：至少是k的选法\nf[0]=1,f[k≠0]不存在，此处为0，且k为负数时合法，视为0\n集合：不超过k的选法\nf[k]=1\n线性DP §\n数字三角形：从顶点出发到i,j的最大路径和\n方格取数：所有从顶点出发走到(i1,k-i1)(i2,k-i2)的路径\n按照两次路径的来自方向可分为四类\n最长上升子序列 §\n集合：所有以第i个数结尾的上升子序列\n怪盗基德的滑翔翼：\n所有上升子序列和下降子序列\n最长公共子序列 §\n集合：所有在第一个序列的前i个字母中，第二个序列的前j个字母中出现的子序列\n按照第i，j个字母是否出现可分为四类\n其中，i不出现j出现这一情况可用f[i-1,j]表示，虽然这个表示并不保证j一定出现，但不影响结果，i出现j不出现同理\ni，j都不出现被包含于上述两种，i，j都出现时（即要求相等）时有f[i-1][j-1]+1\n从而状态转移方程为：f[i][j] = max(f[i-1][j],f[i][j-1],f[i-1][j-1]+1)\n最长公共上升子序列 §\n集合：所有在第一个序列的前i个字母中，第二个序列的前j个字母中出现，且以b[j]结尾的公共上升子序列\n按a[i]是否出现分为两类，a[i]不出现时即为f[i-1,j]\na[i]出现时(a[i]=b[j])，按照上一个元素为k=b[1...j-1]分为若干类，为f[i-1,k]+1\n区间DP §\n石子合并 §\n集合：将第i堆石子到第j堆石子合并成一堆石子的合并方式\nf[i][j] = min(f[i,k]f[k+1,j]+s[i,j])\n环形石子合并 §\n可将题目看作在相邻的石子中连边，一共连n-1条边，根据“缺口”位置在石子合并的基础上再多一重循环 O(n^4)\n要求的是n条长度为n的链上的最小值，可以发现将链重复两边，可以在这条长度为2n的链上找到所有上述的链\n状态压缩DP §\n蒙特里安的梦想 §\n只枚举横向摆放的情况\nf[i,j]对应第i列，被上一列伸出状况以二进制数j表示\n与f[i-1,k]应满足 j&amp;k=0 j|k不存在连续奇数个零\nf[0,0]=1\n答案为f[m,0]\n最短Hamilton路径 §\n集合：所有从0走到j，经过的点为二进制表示i的路径\n小国王 §\n集合：只摆在前i行，摆了j个国王，第i行摆放状态是k的集合\n转移：f[i][j][a]是所有满足a&amp;b==0和a|b没有相邻的1的bf[i-1][j-count(a)][b]的和\n玉米田 §\n集合：只摆在前i行，第i行摆放状态是j的集合\n转移：f[i][a]是所有满足a&amp;b==0和a，b都没有相邻的1的bf[i-1][j-count(a)][b]的和\n炮兵阵地 §\n集合：只摆在前i行，第i-1行摆放状态是j，第i行摆放状态是k的集合\n转移：f[i][a][b]是所有满足a,b,c在相同位上不同时有1且a,b相邻3位上至多只有一个1的f[i-1][c][a]+b中1的个数 的最大值\n树形DP §\n没有上司的舞会 §\n集合：所有以u为根的树中选择，选和不选u的方案\n有依赖的背包问题 §\n集合：所有以u为根的树中选择，体积不超过j的方案\n树的最长路径 §\ndfs从子节点更新到父节点，以该节点为根且从不同子节点出发的最长和次长的路径，是该节点向下的路径\n树的中心 §\ndfs从子节点更新到父节点，以该节点为根且从不同子节点出发的最长和次长的路径，是该节点向下的路径\n再dfs从父节点更新到子节点，子节点的向上路径是父节点向上或向下（向下不能是该子节点）的最大路径加上子节点到父节点的路径\n二叉苹果树 §\n有依赖的背包问题\nf[i][j]以i为根的树中选j条边的最大价值\n战略游戏 §\n类似没有上司的舞会\n集合：以i为根的树中，点i选或不选的所有选法\nf[i][0]=f[s1][1]+…\nf[i][1]=1+min(f[s1][0],f[s1][1])+…\n皇宫看守 §\n集合：以i为根的树中，点i状态为j的所有选法\n被父节点看到f[i][0]=Σmin(f[j][1],f[j][2])\n被子节点看到 任选一个子节点为状态2，其余min(f[j][1],f[j][2]) 所有这样的最小值 \n自己f[i][2]=Σmin(f[j][0],f[j][1],f[j][2])+w[i]\n数位DP §\n一般用前缀的方式计算，注意自己定义的是0-n中还是1-n中\n计数问题 §\n计算0-n中每个数字x在每个位上的出现次数（能构造出多少个数在某位上有x）\n将n的数位分为三部分l mid r\n先枚举l部分小于l的数\n当计算0时，l部分须大于等于1，当计算非0时，l部分可以为0。然后r部分可以任取\n再计算r部分时（即枚举l部分等于l的数）（l=0且x=0时不计算，不存在这种有前导0的数），若mid=x，则r部分可以取0-r，若mid&gt;x，则r部分任取\n\n度的数量 §\n即求0~n中有多少数是b进制表示下只含有k个1，其余皆为0的数\n从高位往下看，若该位大于1，则可以取遍0到全是1的情况（可以直接计算出），直接break，若等于1，则有两种选择，一种该位置为0，在剩下的数中放1（可以直接计算出）。一种该位置为1，剩下的数中能放的1减少。最后记得处理1枚举完的情况\n数字游戏 §\n求不降数数量\n取0-an-1-1时，用动态规划求出\n取an-1时，保证比上一位不降\n集合：最高位为j，且共有i位的不降数\nf[i][j]=Σf[i-1][k](k&gt;=j)\nWindy数 §\n注意(0)137不会被计算到f[4][0]，含前导零的情况要额外加一遍\n或者说，设该数共n位，最高位取0的情况（1-99999999（n-1 个九））实际上是Σf[1~n-1][0~9]\n恨七不成妻 §\nT[i][j][a][b]i位数，最高位为j，该数模7余a，各位数字模7余b\nT[i][j][a][b]由T[i-1][k][a-j*10^(i-1)][b-j]转移\nS0′​+=S0​v1​.s0​+=v2​.s0​S1′​+=kA1​​+kA2​​+...+kAs0​​​=S0​∗k∗10n+S1​v1​.s1​+=v2​.s0​∗k∗10i−1+v2​.s1​S2′​+=kA1​​2+kA2​​2+...+kAs0​​​2=S0​∗(k∗10n)2+2∗k∗10n∗S1​+S2​v1​.s2​+=v2​.s0​∗(k∗10i−1)2+2∗k∗10i−1∗v2​.s1​+v2​.s2​​​\n记忆化搜索 §\n滑雪 §\n集合：所有从(i,j)开始滑的路径\n状态机模型 §\n集合：所有从前i个物品中选，状态为j的方案\n大盗阿福 §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n结点可转移到偷窃不偷窃不偷窃不偷窃，偷窃\n股票买卖IV §\nf[i][j][0]：第i天，已经进行完j次交易\nf[i][j][1]：第i天，正在进行第j次交易\n状态转移方程是：\nf[i][j][0] = max(f[i-1][j][0], f[i-1][j][1]+w[i])\nf[i][j][1] =max(f[i-1][j][1], f[i-1][j-1][0]-w[i])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n结点可转移到持有不持有，持有不持有不持有，持有\n股票买卖V §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n结点可转移到持有不持有的第一天，持有不持有的第一天不持有的第二天及之后不持有的第二天及之后不持有的第二天及之后，持有\nf[i][0]=max(f[i-1][0],f[i-1][2]-w)\nf[i][1]=f[i-1][0]+w\nf[i][2]=max(f[i-1][1],f[i-1][2])\n设计密码 §\n集合：密码串的前i个字母的最后j个字母和模板串前j个字母匹配的方案\n转移：f[i+1][u]=f[i][j1]+f[i][j2]+…\n密码串的第i+1个字母选择a~z导致j转移到不同的u\nf[0][0]=1 答案为f[n][0]+…+f[n][m-1]\n单调队列优化 §\n最大子序和 §\n将问题分类为以序列中哪个元素为结尾的序列\n引入前缀和后问题即为求s[k]-s[k-j] (1&lt;=j&lt;=m)的最大值，滑动窗口解决\n旅行问题 §\n环拉成链\n记录每两个相邻点的油量与距离之差，则题意为所有前区间和大于等于0，也即所有长度为环的长度的窗口中区间和最小值大于等于0\n顺时针下ii+n-1中最小为j，需满足s[j]-s[i-1]&gt;=0，逆时针下i-n+1i，需满足s[j]-s[i+1]&gt;=0\n烽火传递 §\n集合：1-i合法，且点燃第i个烽火台的方案\nf[i]=min(f[j])+w[i] i-m&lt;=j&lt;i\n绿色通道 §\n二分，寻找满足时间不超过t的最长空题段 的最小值\n最长空题段是上一题中的每多少个烽火台至少有一个烽火台的限制，时间是代价\nf[i]=min(f[j])+w[i] i-limit-1&lt;=j&lt;i\n修剪草坪 §\n集合：从前i头牛中选的方案\n由于不能连续选k个，根据在哪个牛不选来分类\nf[i]=max(f[i-1],f[i-x-1]+s[i]-s[i-x]) 1&lt;=x&lt;=k i-k&lt;=i-x&lt;i\n代表不选i-x牛，选i-x到i中的牛\n单调队列计算使f[i-x-1]-s[i-x]最大的i-x\n考虑x=i时，代表前i头中全选，应视f[i-x-1]为0\n理想的正方形 §\n对每行求滑动窗口，再对每列求\n斜率优化 §\n任务安排1，2 §\n将启动时间对所有后续任务影响特殊处理\n集合：前i个任务的方案\nf[i]=min(f[j]+sumt[i]* (sumc[i]-sumc[j])+s*(sumc[n]-sumc[j]))j&lt;i\n斜率优化\nf[j]=(sumt[i]+s)*sumc[j]+f[i]-sumt[i] *sumc[i]-s *sumc[n]\n对于任意给定的i，视f[j]为y，sumc[j]为x，则斜率与j无关为定值且为非正无穷正数，取不同的x确定不同的f[i]\n通过图像观察可知，只保留“凸包”上的点，找到第一个斜率大于k的点\n在本题中，随着i递增，x递增，在插入的时候可以删除队尾不在凸包上的点，（待查询的）k也递增，因此查询的时候可以删除队头小于查询值的点\n\n任务安排3 §\n本题中斜率不是单调递增，只能二分查找\n运输小猫 §\n接到猫的最早时间是t[i]-d[i]，记作a[i]\n人为将猫最早时间排序 接走i~j猫的最早时间为a[j]，等待时间为(j-i+1)*a[j]-s[j]+s[i-1]\nf[j][i] j个饲养员，取前i只小猫的最小花费\nf[j][i]=min(f[j-1][k]+a[i]*(i-k)-s[i]+s[k])\nf[j-1][k]+s[k]=a[i]* k+f[j][i]-a[i]*i+s[i]\n对任意给定i，视f[j-1][k]+s[k]为y，k为x，a[i]递增"},"图图":{"title":"图图","links":[],"tags":[],"content":"光线的表示\n正交和透视投影下光线的出发点和方向\n判定光线与球面的相交\n判定光线与三角形的相交\n判定光线与多边形的相交\n软件流水线 硬件流水线 什么是rasterization pixelwise操作 geometricwise操作"},"多重背包":{"title":"多重背包","links":[],"tags":["算法"],"content":"完全背包加上数量限制\n优化1：类似二进制打包物品 转换成01背包\n优化2：\nf[i,j]=max(f[i−1,j−v]+w,f[i−1,j−2v]+2w,...,f[i−1,j−sv]+sw)f[i,j−v]=max(f[i−1,j−2v]+w,f[i−1,j−3v]+2w,...,f[i−1,j−sv]+(s−1)w,f[i−1,j−(s+1)v]+sw)f[i,j−2v]=max(f[i−1,j−3v]+w,f[i−1,j−4v]+2w,...,f[i−1,j−sv]+(s−2)w，f[i−1,j−(s+1)v]+(s−1)w，f[i−1,j−(s+2)v]+sw)​\n多重背包中求滑动窗口的最大值\n完全背包中求所有前缀的最大值\n滚动数组 因为用到上一层的状态且使用了滑动窗口，所以每次备份上一层的状态"},"完全背包":{"title":"完全背包","links":[],"tags":["算法"],"content":"状态转移方程：\nf[i][j] = max(f[i - 1][j - k * v[i]] + k * w[i])\n由状态转移方程f[i][j]和f[i][j - v[i]]展开并比较它们\nf[i][j - v[i]] = max(f[i - 1][j - v[i] - k * v[i]] + k * w[i])\n后式少了一项f[i-1][j]，并且每项少w[i]\n可以得出简化后的等价状态转移方程f[i][j]=max(f[i - 1][j], f[i][j - v[i]]+w[i])"},"差分":{"title":"差分","links":[],"tags":[],"content":"函数f(x,y)适当光滑连续，且关于y满足Lipschitz条件，即存在常数L，使得\n∣f(x,y)−f(x,y​)≤L∣y−y​∣\n可知 初值问题的解必存在且唯一\nEuler格式 §\n折线法 一阶精度 收敛\n显示 §\nyn+1​=yn​+hf(xn​,y(xn​))\n隐式 §\nyn+1​=yn​+hf(xn+1​,y(xn+1​))\n两步格式\n二阶精度 隐式\nyn+1​=yn−1​+2hf(xn​,y(xn​))\n改进Euler格式\n二阶精度 收敛\n⎩⎨⎧​yp​=yn​+hf(xn​,yn​)yc​=yn​+hf(xn+1​,yp​)yn+1​=21​(yp​+yc​)​\n梯形格式\n二阶精度 隐式\nyn+1​=yn​+2h​[f(xn​,y(xn​))+f(xn+1​,y(xn+1​)]\n代数精度 §\nRunge-Kutta §\n由微分中值定理得\ny(xn+1​)=y(xn​)+hK∗K∗=f(ξ,y(ξ))​\n多预报几个点的斜率\nr阶\n⎩⎨⎧​yn+1​=yn​+h∑j=1r​λj​Kj​K1​=f(xn​,yn​)i=2,⋯,r,Ki​=f(xn​+pi​h∑j=1i−1​μij​Kj​)​\n中点格式\n⎩⎨⎧​yn+1​=yn​+hK2​K1​=f(xn​,yn​)K2​=f(xn+21​​,yn​+2h​K1​)​\n二阶\n具有二阶精度\n⎩⎨⎧​yn+1​=yn​+h[(1−λ)K1​+λK2​]K1​=f(xn​,yn​)K2​=f(xn+p​,yn​+phK1​)​\n满足λp=0.5\n改进Euler格式和中点格式可以看作其特例\nKuuta格式\n具有三阶精度\n⎩⎨⎧​yn+1​=yn​+6h​(K1​+4K2​+K3​)K1​=f(xn​,yn​)K2​=f(xn+21​​,yn​+2h​K1​)K3​=f(xn+1​,yn​+h(−K1​+2K2​))​\n四阶经典\n⎩⎨⎧​yn+1​=yn​+6h​(K1​+2K2​+2K3​+K4​)K1​=f(xn​,yn​)K2​=f(xn+21​​,yn​+2h​K1​)K3​=f(xn+21​​,yn​+2h​K2​)K4​=f(xn+1​,yn​+hK3​)​\nAdams §\nyn+1​=yn​+hK(yn+1′​,yn′​,yn−1′​,⋯)\nEuler显示格式和隐式格式是一阶Adams格式\n二阶显示Adams格式\nyn+1​=yn​+2h​(3yn′​−yn−1′​)\n二阶隐式Adams格式\n即梯形格式\n二阶Adams预报校正系统\n⎩⎨⎧​y​n+1​=yn​+2h​(3yn′​−yn−1′​)y​n+1′​=f(xn+1​,y​n+1​)yn+1′​=yn​+2h​(y​n+1′​+yn′​)yn+1​=f(xn+1​,yn+1​)​\n改进的二阶Adams预报校正系统\n三阶精度\n⎩⎨⎧​pn+1​=yn​+2h​(3yn′​−yn−1′​)mn+1​=pn+1​−65​(pn​−cn​)mn+1′​=f(xn+1​,mn+1​)cn+1​=yn​+2h​(mn+1′​+yn′​)yn+1​=cn+1​+61​(pn+1​−cn+1​)yn+1′​=f(xn+1​,yn+1​)​\n四阶显示和隐式Adams格式\nyn+1​=yn​+24h​(55yn′​−59yn−1′​+37yn−2′​−9yn−3′​)yn+1​=yn​+24h​(9yn+1′​+19yn′​−5yn−1′​+yn−2′​)​\n四阶Adams预报校正系统\ny​n+1​=yn​+24h​(55yn​−59yn−1′​+37yn−2′​−9yn−3′​)y​n+1′​=f(xn+1​,y​n+1​)yn+1​=yn​+24h​(9y​n+1′​+19yn​−5yn−1′​+yn−2​)yn+1′​=f(xn+1​,yn+1​)​\n改进的四阶Adams预报校正系统\n​pn+1​=yn​+24h​(55yn′​−59yn−1′​+37yn−2′​−9yn−3′​)mn+1​=pn+1​−270251​(pn​−cn​)mn+1′​=f(xn+1​,mn+1​)cn+1​=yn​+24h​(9mn+1′​+19yn′​−5yn−1′​+yn−2′​)yn+1​=cn+1​+27019​(pn+1​−cn+1​)yn+1′​=f(xn+1​,yn+1​)​\n收敛性\n公式本身截断误差对计算结果的影响\n称收敛的，当h趋于0同时n趋于无穷大时，数值解趋于准确解\nEuler格式，改进Euler格式，龙格库塔方法都是\n稳定性\n某个公式在计算过程中出现的误差对计算结果的影响\n称稳定的，当在某个节点上有扰动，后续节点偏差不超过该值\nEuler格式，改进Euler格式，四阶龙格库塔方法条件稳定\n梯形格式恒稳定\n隐式Euler对正h绝对稳定"},"插值":{"title":"插值","links":["计算方法"],"tags":[],"content":"一致逼近\n∣∣f(x)−g(x)∣∣∞​=maxa≤x≤b​∣f(x)−g(x)∣\n平方逼近\n∣∣f(x)−g(x)∣∣2​=∫ab​∣f(x)−g(x)∣2dx​\n插值平均\ny=i=0∑n​λi​yi​\n代数精度 §\nm阶精度 满足次数≤m的幂函数 即\nλ0​+λ1​=1λ0​x0​+λ1​x1​=xλ0​x02​+λ1​x12​=x2...​\n多点插值 §\ny=i=0∑n​(j=0j=i​∏n​xi​−xj​x−xj​​)yi​\n三点为例\ny=(x0​−x1​)(x0​−x2​)(x−x1​)(x−x2​)​y0​+(x1​−x0​)(x1​−x2​)(x−x0​)(x−x2​)​y1​+(x2​−x0​)(x2​−x1​)(x−x0​)(x−x1​)​y2​\nAitken逐步插值算法 §\n化为两点插值\n(x0,y0)(x1,y1)(x2,y2)先用0分别和1，2插值得到y01,y02\n(x1,y01)(x2,y02)再插值得到结果\nfk​(xi​)=xk−1​−xi​x−xi​​fk−1​(xk−1​)+xi​−xk−1​x−xk−1​​fk−1​(xi​),(i≥k)\nk对应列数\n\n按照与所求点的距离由近到远排列 逐行生成插值表 当该行最后一个元素达到精度要求停止\nNevilles\n\nIi0​,ik+1​​(x)=Ii0​,ik​​(x)xi0​​−xik+1​​x−xik+1​​​+Ii1​,ik+1​​(x)xik+1​​−xi0​​x−xi0​​​\nTaylor插值 §\n在所求点有一定精度\npn​(x)=f(x0​)+f′(x0​)(x−x0​)+2f′′(x0​)​(x−x0​)2+...+n!f(n)(x0​)​(x−x0​)n\nLagrange插值 §\n过一系列的点\npn​(x)=k=0∑n​λk​(x)f(xk​)\nλk​(x)=j=0j=k​∏n​xk​−xj​x−xj​​\nλk​(xk​)=1λk​(xj​)=0,j=k​\nlambda k为n次式\nHermite插值 §\n例1 §\n作二次式满足\np2​(x0​)=y0​,p2′​(x0​)=y0′​,p2​(x1​)=y1​\n法1 待定系数\n法2 余项校正\n先作p1过两点\np1​(x)=x0​−x1​x−x1​​y0​+x1​−x0​x−x0​​y1​\n再加上余项\np2​(x)=p1​(x)+c(x−x0​)(x−x1​)\n法3 基函数\n为简化，先设x0=0,x1=1\np2​(x)=y0​φ0​(x)+y1​φ1​(x)+y0′​ψ0​(x)\nφ0​(0)=1,φ1​(1)=1,ψ0′​(0)=1,​φ0​(1)=φ0′​(0)=0φ1​(0)=φ1′​(0)=0ψ0​(0)=ψ0​(1)=0​\n其中基函数均为二次式\n当x0,x1为任意节点时\np2​(x)=y0​φ0​(hx−x0​​)+y1​φ1​(hx−x0​​)+hy0′​ψ0​(hx−x0​​)\nt=hx−x0​​,h=x1​−x0​\n例2 §\n作三次式满足\np3​(x0​)=y0​,p3′​(x0​)=y0′​,​p3​(x1​)=y1​p3′​(x1​)=y1′​​\n运用基函数方法\np3​(x)=y0​φ0​(hx−x0​​)+y1​φ1​(hx−x0​​)+hy0′​ψ0​(hx−x0​​)+hy1′​ψ1​(hx−x0​​)\nφ0​(0)=1,φ1​(1)=1,ψ0′​(0)=1,ψ1′​(1)=1,​φ0​(1)=φ1′​(0)=φ1′​(1)=0φ1​(0)=φ1′​(0)=φ1′​(1)=0ψ0​(0)=ψ0​(1)=ψ0′​(1)=0ψ0​(0)=ψ1​(1)=ψ1′​(0)=0​\n一般形式Hermite插值多项式\np2n+1​=i=0∑n​[φi​(x)yi​+ψi​(x)yi′​]\nn=1 两个点 三次式\nφ0​(x)=(1+2x1​−x0​x−x0​​)(x0​−x1​x−x1​​)2φ1​(x)=(1+2x0​−x1​x−x1​​)(x1​−x0​x−x0​​)2ψ0​(x;)=(x−x0​)(x0​−x1​x−x1​​)2ψ1​(x)=(x−x1​)(x1​−x0​x−x0​​)2​\n分段插值 §\nS3​(xi​)=yi​,S3′​(xi​)=yi′​,i=0,1,⋯,n\n在子段[xi,xi+1]上，\nSi​(x)=φi​(hi​x−xi​​)yi​+φi​(hi​x−xi​​)yi+1​+hi​φi​(hi​x−xi​​)yi′​+hi​φi​(hi​x−xi​​)yi+1′​,xi​⩽x⩽xi+1​​\nhi​=xi+1​−xi​\n样条插值 §\n三次样条 §\n称S3(x)为具有分化Δ的三次样条，如果它在每个子段上都是三次式，且在内节点上具有直到二阶的连续导数\nS3​(xi​−0)=S3​(xi​+0),S3′​(xi​−0)=S3′​(xi​+0),i=1,2,⋯,n−1S3′′​(xi​−0)=S3′′​(xi​+0),​\n先考虑函数值和一阶导数，即计算方法\nS3​(x)=φi​(hi​x−xi​​)yi​+φi​(hi​x−xi​​)yi+1​+hφi​(hi​x−xi​​)mi​+hφi​(hi​x−xi​​)mi+1​,xi​&lt;x&lt;xi+1​​\nS3′′​(x)=hiz​6​[2(hi​x−xi​​)−1]yi​−hi2​6​[2(hi​x−xi​​)−1]yi+1​+hi​1​[6(hi​x−xi​​)−4]mi​+hi​1​[6(hi​x−xi​​)−2]mi+1​​\nS3′′​(xi​)S3′′​(xi+1​)​=6hi2​yi+1​−yi​​−hi​4mi​+2mi+1​​=−6hi2​yi+1​−yi​​+hi​2mi​+4mi+1​​​\n保证二阶导数连续\nhi−1​mi−1​+2mi​​+hi​2mi​+mi+1​​=3(hi−12​yi​−yi−1​​+hi2​yi+1​−yi​​)\n拟合 §\n最小二乘法\n实测值为yi\n定义残差\nei​=yi​−y^​i​\n使残差平方和（总误差）最小\n对于直线拟合\nQ=i=1∑N​[yi​−(a+bxi​)]2\n使得总误差最小\n∂a∂Q​=0,∂b∂Q​=0{aN+b∑xi​=∑yi​a∑xi​+b∑xi2​=∑xi​yi​​\n对于多项式拟合\nQ=i=1∑N​(yi​−j=0∑m​aj​xij​)2\n∂ak​∂Q​=0,k=0,1,⋯,mi=1∑N​(yi​−i=0∑n​aj​xij​)xik​=0,k=0,1,⋯,m​\n⎩⎨⎧​ai​N+a1​∑xi​+⋯+an​∑xin​=∑yi​ai​∑xi​+a1​∑xi2​+⋯+an​∑xin+1​=∑xi​yi​⋮ai​∑xin​+ai​∑xin+1​+⋯+an​∑xi2n​=∑xin​yi​​\n正则方程组"},"操作系统":{"title":"操作系统","links":[],"tags":["example-tag"],"content":"操作系统导论中的一组概念\n机制：功能的实现\n策略：智能，做出的决定\n进程的组成包括寄存器，其访问的内存（地址空间），程序计数器\nunix中提供的进程API\nfork §\n创建新进程，在父进程中返回值为子进程ID，在子进程中返回值为0，子进程创建后从fork返回（开始执行）\nwait\nexec\nexecve\n状态机的重置\n一切进程strace的第一个调用\n环境变量会在此时传入（控制了程序行为 ssh同一台机器 行为会在不同的电脑输出结果） 环境变量会继承父进程\nfork和exec的组合使用例子 shell\n机制\n受限直接执行\n有限制，允许进程间切换（上下文切换 硬件时钟中断 硬件保存；操作系统调度 操作系统保存）\n进程调度\n调度指标 周转时间（性能）完成时间-到达时间\nSJF，STCF\n响应时间（交互）首次运行-到达\nRR 公平\n软件是现实世界需求的投影，而（软件）代码这一投影是有损的，比如一个代表金钱的变量应当有所限制，代码并不能很简单直接的表达这一限制\n调试理论 fault到failure中经历了很长的距离，防御性编程这种方式可以迅速捕获fault\n懒得做sanitizer？\n检测数据冒险（图上的可达问题）和潜在死锁的方式\n信号量\n挺适合表示表示先后关系（前驱图）\n内存虚拟化\n页表 多重页表 页表目录\n操作系统在完成了初始化工作之后感觉就变成了中断处理。（时钟中断， 主动 系统调用等）"},"故事":{"title":"故事","links":[],"tags":[],"content":"Part One\n故事是生活的比喻\n贞德的生活事实永远都是相同的，但每当其生活真谛的意义被作家发现时，整个类型便随之改变了\n电影美学是表达故事生动内容的手段 但不是目的\n知觉力 描述现实\n想象力\n如果要在讲的精彩的琐碎素材和讲的拙劣的深奥素材之间进行选择的话，听众总是会选择讲的精彩琐碎故事。\nPart Two\n要设计一部故事片，你必须将沸扬熙攘的生活故事浓缩在2小时左右，而又同时表达出你所割舍一切\n结构是对人物生活故事中一系列事件的选择，这种选择将事件组合成一个具有战略意义的序列以激发特定的情感并表达一种特定而具体的人生观。\nChapter05\n人物塑造是一切可以观察到的人的素质的总和，一切通过仔细考察便可获知的东西。这一切特征的总和使得每一个人都独一无二，因为每一个人都是通过遗传给予和经验累计组合而成的仅此一个的个体。但这不是人物。\n人物性格真相在人物处于压力之下做出选择时得到揭示。\n虚构人物与结构之间常见的运作方式\n1.铺陈人物塑造特征2.引入人物内心3. 本性与人物面貌冲突4.施加压力 要他做出越来越困难的选择5.待到故事高潮 选择已经深刻改变了人物人性\n结构提供压力，将角色逼向越来越困难的两难之境，揭示出其真实本性，甚至是无意识的自我\n结构和人物是互相连锁的。故事的事件结构来自人物在其压力之下所做出的选择和采取的行动；而人物则是通过在压力之下的选择和行动来揭示和改变的生物。两者是同时被改变的。如果你改变了事件设计，那么也就改变了人物; 如果你改变了人物的深层性格，就必须再造结构来表达人物被改变了的性格。\n故事讲述是对真理的创造性论证。一个故事是一个思想的活证据，完成思想到动作的转换。故事的事件结构是一种手段，你通过它表达你的思想，并随后将其证明……且绝不采用任何解释性的话语。\n主控思想可以用一个句子来表达，描述出生活如何以及为何会从故事开始时的一种存在状况转化为故事结局时的另一种状况。\n价值加原因\n故事进展通过在故事中押上合面的各种价值的正面负荷和负面负荷之间的动态移动而构建起来。\n平衡讲述手法 不要说教\n证明你观点的证据并不在于你能多么强硬地断言你的主控思想， 而在于它将如何战胜你为他部署的各种强大的对抗力量。\n一部伟大的作品是一个鲜活的比喻，告诉我们 “生活就像是这样”。有史以来，所有经典作品给子我们的并不是解决办法，而是一剂令我们保持清醒的良药。并不是答案，而是富有诗意的率真，它们把人类世世代代之所以为人而 必须解决的问题不可回避地昭然于天下。\n对当代价值——成功、财富、名誉、性、权力的过分追求将会摧毁你，但你只要能及时看清这一真理并抛弃你的执着，便能使自己得到救赎。\n如果你一味地痴迷于你的执着，你无情的追求将会满足你的欲望：然后毁灭你自己。\n社会责任\n主人公 自觉愿望 与之矛盾的不自觉愿望 有能力做到愿望 至少有一次机会达成欲望\n主人公有意志和能力追求其自觉和/或不自觉的欲望，一直到线索的终点，一直到背景和类型所确立的人类极限。\n故事的艺术不在于讲述中间状态，而在于讲述人类生存状况的钟摆在两板之间摆动的情形，讲述在最紧张状态下所经历的人生。\n移情作用 在放事中，我们将精力集中于那一瞬间，且仅仅是那一瞬间，人物在那一瞬间采取行动，期望他的世界做出一个有益的反应，但其行动的 效果却是引发出了各种对抗力量。人物的世界所做出的反应要么与他的期望大相径庭，要么比他期望的反应更为强烈，要么二者兼有。\n\n或然性和必然性的鸿沟\n激励事件必须彻底打破主人公生活中各种力量的平衡。\n对许多故事或类型而言，这便已经足一个事件把主人公的生活推向混乱，激发起一个自觉的欲望，使他力图找寻他觉得能够整饬这种混乱的东西，并为得到而采取行动。\n应该把主情节的激励事件尽快引入⋯…但务必等到时机成熟\n次情节可以用于与主情节的主控思想构成回响，从而以同一主题的多种变异来丰富影片。\n观众那灵活而极富感知力的头脑在理解的一闪念之间找到了问题的答案。为什么？“这个问题把他们推到故事的前面，他们所香过的故事内容立即重新组合为一个新的格局；他们对人物和世界有了深入的理解，挖掘出一层令他们满足的隐藏真理。\n讲故事就是许诺：如果你注意听我讲，我就给你惊奇，接下来便是发现生活的喜悦，在你从未想象过的层面和方向探知生活的喜怒哀乐。而且，最重要的是，这一切必须处理得那样轻松自然，以使观众不知不觉中就被引向了那些 发现。\n一个漂亮的转折时刻起到的效果是，当观众突然获得了某种见解时，看起来就好像是他们自己做到了这一点。在某种意义上而言，他们也的确如此。见解是观众注意听故事所得到的奖励，而且一个设计漂亮的故事能够一个场景接着一个场景地激发出这种愉悦。\n◎伏笔和分晓 为了一幕一幕地表达我们的视觉，我们将虛构现实的表皮破开，并把观众兴到故車前面部分以获得见解。因此，这些见解必须以伏笔和分晓的方式进行沟建。铺设伏笔是指，将知识一层一层铺垫好；分晓是指，将铺设的知识传达 给观众以闭合鸿沟。\n在故事讲述过程中，逻辑是一种可以回溯前文去重建的东西。故事不同于生活，你可以随时回头对故事进行修\n补。你可以埋下一个看似荒谬的伏笔，并使它变得合乎情理。推理是第二位的，属于后创作范畴。想象是高于其他一切的第一位的先决条件一你必须自愿地去想象任何疯狂的念头，让那些无论是否合乎情理的形象进入你的脑海。其中十有八九将毫无用处，可是，一个不合设辑的想法也许会让你的想象长出翅膀，迸发出一种启示，告诉你在这个疯狂念头下面隐藏着的一个妙笔。在直觉闪现的一利那，你看到了其间的联系，意识到，你可以回头改写，使之合乎情理。所谓逻辑，只不过是一种儿戏。只有想象才能使你走上银幕。\n作为观众，当故事的讲述过程带领我们经历一种价值的转变时，我们便会体验到一种情感。首先，我们必须移情于人物。其次，我们必须知道人物想要什么并希望他得到他想要的东西。第三，我们必须明白人物生活中，押上台面的价值。在这种情况下，一个价值的改变便能打动我们的情感。\n回报递减定理无论是在生活中还是在故事中，都同样成立：我们对某事的体验越多，它所产生的效果就会越少。\n事实上，“严肃”情感的重复是一种行家惯用的喜剧手法。情感是一种短期的体验，达到高峰之后便迅速燃烧殆尽。感情却是一种长期的、具有渗透性、弥漫性和知觉性的背景情绪，可以为我们人生的整天、整月或整年增添色彩。\n当我们需要基调体验时，我们会去听音乐会或去参观博物馆。当我们需要意味深长的情感体验时，我们就会去听故事。\n正面 矛盾 相反 负面之负面（否定之否定）\n真正的选择是两难之择"},"数据库":{"title":"数据库","links":[],"tags":[],"content":"超码 §\n唯一标识出一个元祖的属性集\n超码的超集是超码\n候选码 §\n最小的超码\n可选作为主码\n外码 §\n关系r中一个属性集F的取值范围是另一个关系s的主码的取值范围的子集\n称F是关系r的外码，关系r为参照关系\n选择\n返回满足谓词的行\n投影\n只保留指定的列，去除重复元组\n自然连接\n作笛卡尔积，只保留在共同属性上有相同值的元组，公共属性不重复保留\n连接\n作笛卡尔积，保留满足谓词的元组\n除法\nR/S 结果元组满足\n1.属性集为R-S\n2.其S属性在关系S中出现\n由上方例子可以得到关系除法:R1÷R2 的方法是：1、寻找两个集合的公共属性，找出R1中的所有能构成R2中的公共属性的组合的元组的组合的集合。然后对每个集合验证其中元组组合中的各元组除公共属性外其他属性是否相同，若相同其中任意一个元组除公共属性外的其他属性为结果中的一个元组。\n外连接\n保留自然连接中未配对的元组\n多值属性\n建模方案\n1.转换为多个单值属性，电话号码变成移动电话，宿舍电话等\n2.建模为弱实体集\n弱实体集\n弱实体集的存在依赖于标识实体集\n标识性联系是弱实体集到标识性实体集的多对一联系，且弱实体集全部参与"},"数理逻辑":{"title":"数理逻辑","links":[],"tags":["离散数学"],"content":"命题 §\n判断结果惟一的陈述句\n\n命题常元 （命题常项） §\n⊥ （bottom)，（top）\n蕴含式 §\np→q 的逻辑关系可以是\nq为p的必要条件\n如果 p, 则q\n若p，就q\n只要p，就q\np仅当q\n只有q才p\n除非q, 才p 或 除非q，否则非p\n因为p，所以q\n联结词运算的 优先次序 §\n¬\n∧\n∨\n→, ↔同级按先出现者先运算\n基本等值式 §\n\n\n\n主析取范式 极小项（成真赋值 与）的析取（或）\n主合取范式 极大项（成假赋值 或）的析取（与）\n极小项与极大项互补\n真值函数 §\nF:{0,1}n→{0,1}\nn元真值函数 n个命题变项可构成2的2的n次个n元真值函数\n\n\n联结词完备集 §\n可表示任意n元真值函数\n\n\n\n\n推理定律 §\n\n闭式 §\n没有自由变量\n封闭的公式在任何解释下都能变成命题，而非闭式就不一定 需要再加上赋值\n所有的整数都有质因子。\n理解成“对所有x，若x是整数，那么x有质因子”\n(∀x)(I(x) → P(x))\n有些猪有翅膀。\n理解为“至少有一个物体x，x是猪并且x有翅膀。”\n(∃x)(P(x) ∧ W(x))\n\n\n\n\n全称量词消去规则 §\n∀xP(x)⇒P(y) ∀xP(x)⇒P(c)\ny为任意的不在P(x)中约束出现的个体变项 c为任意个体常项\n全称量词引入规则 §\nP(y)⇒∀xP(x)\ny为论域中任一个体 且P(y)始终为真\n取代自由出现的y的x不能在P(y)中约束出现\n存在量词引入规则 §\nP(a)⇒(∃x)P(x)\na是特定个体常项\n取代a的x不在P(a)中出现过\n存在量词消去规则 §\n(∃x)P(x) ⇒P(a)\na不在P(x)中出现 P(x)中没有其他自由出现的个体变项 a在推导中未使用过\n先消去存在量词 再全称"},"方程求根":{"title":"方程求根","links":[],"tags":[],"content":"根的二分搜索\n一定收敛 收敛慢 不适合偶数重根\n∣x∗−xk​∣≤2bk​−ak​​=2k+1b−a​\n终止条件\n∣xk+1​−xk​∣&lt;ϵ1​\n∣f(x)∣&lt;ϵ2​\n二分次数\nk&gt;ln2ln(b−a)−ln(ϵ)​−1\n迭代法\n将方程f(x)=0改写成x=ψ(x)\nxk+1​=ϕ(xk​)\n几何意义 两条线的交点\n压缩映像原理\n\n\n\n迭代公式加速\n​xˉk+1​=φ(xk​)xk+1​=1−L1​xˉk+1​−1−LL​xk​​\n其中L的选取涉及phi的导数\nAitken加速方法\n​xˉk+1​=φ(xk​)x~k+1​=φ(xˉk+1​)xk+1​=x~k+1​−x~k+1​−2xˉk+1​+xk​(x~k+1​−xˉk+1​)2​​\n开方法\nxk+1​=21​(xk​+xk​a​),k=0,1,2,...\n对任意大于0给定初值收敛，收敛速度较快\nNewton法 §\n选取迭代函数\nϕ(x)=x−f′(x)f(x)​\nNewton法在单根邻近为平方收敛\n优点：收敛快\n缺点：初值敏感，重根难收敛，迭代函数难计算\nNewton下山法 §\n迭代值单调递减\nxk+1​=xk​−λf′(xk​)f(xk​)​\n下山因子lambda保证单调递减，可以从1开始减半尝试\nNewton重根法\nm重根 平方收敛\nxk+1​=xk​−mf′(xk​)f(xk​)​\n弦截法和快速弦截法\nxk+1​=xk​−f(xk​)−f(x0​)f(xk​)​(xk​−x0​)\nxk+1​=xk​−f(xk​)−f(xk−1​)f(xk​)​(xk​−xk−1​)\n弦截法为线性收敛\n用差商替代导数\n{J(x(k))Δx(k)=−F(x(k))x(0)​"},"概率论":{"title":"概率论","links":["概率论"],"tags":[],"content":"样本空间 §\n样本点构成的集合，记为 Ω\n样本点 §\n每一个可能的结果，记为ω\n随机事件 §\n样本空间的一个子集，简称事件\n必然事件Ω , 不可能事件∅  为平凡子集\n事件 A 发生即该子集 A 中至少有一个样本点出现。\n基本事件 §\n由单个样本点构成的样本空间的子集 记作{ω}\n事件间的关系 §\n包含 §\nA 发生必然导致 B 发生，记为 B⊂A ，或 A⊃B 。\n相等 §\n若 B ⊂A  且 B⊃ A ，记为 A = B 。\n对立（互逆） §\nA B中有且仅有一个发生\nA ∩B = Ω， A B =  ∅\n互不相容（互斥） §\nA ， B 不能同时发生\nA B =  ∅\n抽样方式 §\nn 个元素抽取 r 个\n(1) 放回抽样, 计序, 有n^r种结果,( 可重复的排列)\n(2) 不放回, 计序, 有An选r种\n(3) 不放回, 不计序, 有Cn选r种结果\n超几何分布 §\nCNn​CMm​CN−Mn−m​​\n一批产品共 N 个，其中 M 个为次品，从中任取 n个产品，求其中恰有 m 个次品的概率\n二项分布 §\n(a+b)nCnk​akbn−k​=Cnk​pk(1−p)n−kp=a+ba​\n分组情况数计算 §\n\n概率古典定义 §\n注意保证等可能性\n概率公理化定义 §\nP(∅)=0\nA1,A2,…,An两两互不相容\nP(A1​∪A2​∪...∪An​)=P(A1​)+P(A2​)+...+P(An​)\nA⊂B\nP(B−A)=P(B)−P(A)且P(B)≥P(A)\n推论\nP(B−A)=P(B)−P(AB)\nP(A)≤1\nP(A)=1−P(A)\nP(A∪B)=P(A)+P(B)−P(AB)\n条件概率 §\n给定一个随机试验, Ω 是它的样本空间,对于任意两个事件 A,B, 其中P(A)&gt;0, 称P(B|A)为在已知事件A发生的条件下, 事件B 的条件概率\nP(B∣A)=P(A)P(AB)​\n各个公式同上\n独立 §\nP(AB)=P(A)P(B)\n定理 四对事件： A与 B、 A反与 B 、 A 与 B反、 A 反与 B反 ，若其中一对相互独立，则其它三对也相互独立。\n伯努利概型\n相互独立，重复，结果只有两个\n样本空间的划分\n全概率公式 §\nBi是Ω的一个划分\nP(A)=i=1∑n​P(A∣Bi​)P(Bi​)\n贝叶斯公式 §\n后验概率\nBi是Ω的一个划分\nP(Bi​∣A)=P(A)P(ABi​)​=j=1∑n​P(Bj​)P(A∣Bj​)P(Bi​)P(A∣Bi​)​\n随机变量 §\n设随机试验的样本空间Ω={ω}，若对每一个ω，有一个实数ξ与之对应，则得一定义在上的单值实值函数ξ=ξ(ω)称为随机变量\n随机变量可分为离散型，连续型\n随机变量分布律 §\n非负性 均非负\n规范性 和为1\n分布函数 §\n设ξ是一个随机变量， x 是任意实数\nFξ​(x)=P{ω∣ξ(ω)≤x}=P{ξ≤x}\n定义域为实轴\n任意随机变量都存在唯一的分布函数，但同一分布函数可对应不同随机变量。\n分布函数有非减性，右连左极性，取值范围0到1\n具有上述性质的函数可视作某一随机变量的分布函数\nP{ξ&lt;a}=n→∞+lim​P{ξ≤a−n1​}=n→∞+lim​F(a−n1​)=F(a−0)​\n离散型随机变量 §\n分布律具有非负性和规范性\nP(ξ=xk​)=pk​=F(xk​)−F(xk​−0)F(x)=P{ξ≤x}=∑xk​≤x​P{ξ−xk​}​\nF(x)=⎩⎨⎧​0,p1​,p1​+p2​,p1​+p3​+p3​,⋮p1​+p2​+⋯+pn​=1,​x&lt;x1​x1​≤x&lt;x2​x2​≤x&lt;x3​x3​≤x&lt;x4​⋮x≥xn​​\n连续型随机变量 §\n如果对于随机变量ξ的分布函数存在非负函数p(x)，使得对于任意实数x，有\nF(x)=∫−∞x​p(t)dt\n则称ξ为连续型随机变量，其中p(x称为ξ的概率密度函数\n概率密度具有非负性和规范性\n两点分布 §\npk​={p1−p​k=0k=1​\n均匀分布 §\nξ～U(a,b)\np(x)=⎩⎨⎧​b−a1​0​a&lt;x&lt;b其他​\n指数分布 §\nξ~E(λ)\np(x)={λe−λx0​x&gt;0x≤0​\n无记忆性\n对任意s&gt;0,t&gt;0,成立P(X &gt; s+t | X &gt; s) = P (X &gt; t)\n正态分布 §\nX~N(μ,σ2)\np(x)=2π​σ1​e−2σ2(x−μ)2​,−∞&lt;x&lt;+∞\np (x) 的性质：\n图形关于直线 x = μ对称, 即\np(μ + x) =p(μ - x).\n在 x = μ 时, p(x) 取得最大值\n标准正态分布\nN(0,1)\n分布函数\nΦ(x)=2π​1​∫−∞x​e−2t2​dt     −∞&lt;x&lt;+∞\nΦ(0) = 0.5\nΦ(-x)=1-Φ(x)\n若随机变量X~N(μ,σ2)，X的分布函数为F(x)，则F(x)=Φ(x-μ/σ)\n随机变量函数的概率密度函数 §\n若是y=f(x)单调函数，其反函数x=g(y)，则随机变量的函数Y=f(X)的概率密度函数\npY​(y)=pX​(g(y))​g′(y)​\n由F求p法\nFY​(y)=P(Y≤y)=P(F(X)≤y)\n二维随机变量 §\n设随机试验 E的样本空间是Ω={ω} 设X=X{ω}和Y=Y{ω}是定义在Ω上的随机变量，则由它们构成的一 个向量(X ,Y) 称为二维随机变量或二维随机向量。\n联合分布函数 §\n二维随机变量的分布函数\n设 (X ,Y) 是二维随机变量，对于任意实数 x, y, 二元函数\nF(x,y)​=P{(X≤x)⋂(Y≤y)}=P{X≤x,Y≤y}​\n称为二维随机变量(X,Y)的分布函数，或联合分布函数\nP{x1​&lt;X≤x2​,y1​&lt;Y≤y2​}=F(x2​,y2​)−F(x1​,y2​)−F(x2​,y1​)+F(x1​,y1​)​\n性质 §\n①F(x,y)是变量 x和 y各自的单调非降函数\n② 0≤ F(x,y)≤ 1 F(−∞,y)=0 F(x,−∞)=0  F(−∞,−∞)=0  F(+∞,+∞)=0\n③ F(x,y)关于 x, y 各自右连续，即 F(x,y) = F(x+0,y) F(x,y)=F(x,y+0)\n由联合分布律求离散型分布函数\nF(x,y)=xi​≤x∑​yj​≤y∑​pi​\n二维连续型随机变量 §\n设二维随机变量 (X ,Y)的分布函数为 F(x,y), 若存在f(x,y) ≥ 0，使得对任意实数 x，y  , 总有\nF(x,y)=∫−∞y​∫−∞x​f(u,v)dudv\n则称 (X ,Y)为二维连续型随机变量, f(x,y) 称为(X ,Y)的 概率密度,或称为随机变量 X 和Y的联合概率密度。\n二维均匀分布 §\n若二维随机变量(X, Y)的密度函数为\nf(x,y)=⎩⎨⎧​D的面积1​,(x,y)∈D0,其他​\n则称(X, Y)在区域D上(内) 服从均匀分布。\n性质：若（X，Y）在区域D上(内) 服从均匀分布， 则对D内的任意子区域G，都有\nP{(X,Y}∈G}=SD​SG​​\n二维正态分布 §\n设 μ1 , μ 2 , σ 1 , σ 2 , ρ 为五个常数， 且 σ 1 &gt;0 ， σ 2 &gt; 0， |ρ |≤ 1，随机变量 (ξ ,η ) 具有如下 密度函数，则称 (ξ ,η ) 服从二维正态分布\nρ(x,y)=2πσ1​σ2​1−ρ2​1​×exp{−2(1−ρ2)1​[σ12​(x−μ1​)2​−2ρσ1​σ2​(x−μ1​)(y−μ2​)​+σ22​(y−μ2​)2​]}−∞&lt;x,y&lt;+∞​\n边际分布函数 §\n二维随机变量 (ξ ,η) 关于 ξ ,η 的边际（边缘）分布函数\n二维离散随机变量的边际分布列 §\n假设二维离散随机变量 (ξ ,η ) 的概率分布为：\nP(ξ=xi​,η=yj​)=pi​,i,j=1,2,⋯\n则\n[f]​P(ξ=xj​)=P{ξ=xi​,j=1⋃∞​(η=yj​)}=P{j=1⋃∞​(ξ=xi​,η=yj​} = j=1∑∞​P(ξ=xi​, η=yj​)​\n记作\npi∙​​=j=1∑∞​pij​​,i=1,2,⋯\n称为 ξ 的边际分布列\n二维连续随机变量的边际分布列 §\n已知二维随机变量 ( ξ,η )的联合概率密度为p(x,y)\nξ 的边缘分布函数\nFξ​(x)=F(x,+∞)=∫−∞x​dx∫−∞+∞​p(x,y)dy\nξ 的边缘概率密度\npξ​(x)=∫−∞+∞​p(x,y)dy\nη 的边缘分布\nFη​(y)=F(+∞,y)=∫−∞y​dy∫−∞+∞​p(x,y)dx\nη 的边缘概率密度\npη​(y)=∫−∞+∞​p(x,y)dx\n二维条件分布 §\n离散型随机变量的条件分布\n假设二维离散随机变量(ξ ,η)的联合概率分布为\nP(ξ=xi​,η=yj​)=pij​,i,j=1,2,⋯,\n则\nP(ξ=xi​∣η=yj​)=P(η=yj​)P(ξ=xi​,η=yj​)​=pj∙​pij​​,i=1,2,…​\n​P(η=yj​∣ξ=xi​)=P(ξ=xi​)P(ξ=xi​,η=yj​)​=pj∙​pi,j​​,j=1,2,…​\n离散型随机变量的条件分布\n在 η = y 条件下，求连续随机变量 ξ 的条件概率密度\npξ∣η​(x∣y)=pη​(y)p(x,y)​\n在ξ = x 的条件下， 条件概率密度函数\npη∣ξ​(y∣x)=pξ​(x)p(x,y)​\n二维随机变量的独立性 §\n设 (ξ,η )为二维随机向量，若对任意的实数 x,y 成立乘法关系\nP(ξ≤x,η≤y)=P(ξ≤x)P(η≤y)\n即\nF(x,y)=Fξ​(x)Fη​(y)\n则称ξ和η相互独立\n离散型随机变量的独立性\nP(ξ=xi​,η=yj​)=P(ξ=xi​)⋅P(η=yj​),i=1,2,⋯,j=1,2,⋯​\npij​=pi∙​p∙j​\n连续型随机变量的独立性\np(x,y)=pξ​(x)⋅pη​(y)\n联合密度函数的非零区域为矩形\n多维随机变量函数 §\n离散型\n独立的多个二项/泊松分布可加\nXB(n1,p),YB(n2,p),X+YB(n1+n2,p)\nXP(lamb1),YP(lamb2),X+YP(lamb1+lamb2)\n连续型\n和函数的分布\nZ=X+Y\nFZ​(z)=P{X+Y≤z}=x+y≤z∫​pXY​(x,y)dxdy=∫−∞+∞​dx∫−∞z−x​pXY​(x,y)dy​\npZ​(z)=∫−∞+∞​pXY​(x,z−x)dx\n独立的两个正态分布可加\n最大值与最小值的分布\nX,Y独立\nFmax​(z)=P{max(X,Y)≤z}=P(X≤z,Y≤z)=P(X≤z)P(Y≤z)=FX​(z)FY​(z)​\n​​​Fmin​(z)=P{min(X,Y)≤z}=1−P(min(X,Y)&gt;z)=1−P(X&gt;z,Y&gt;z)=1−P(X&gt;z)P(Y&gt;z)=1−[1−P(X≤z)][1−P(Y≤z)]=1−[1−FX​(z)][1−FY​(z)]​\n分布函数能完整地描述 r.v.的统计特性,但实际应用中并不都(需要)知道分布函数，而只(需)知道 r.v.的某些特征.\n随机变量某一方面的概率特性可以用数字特征来描述.\n数学期望 §\nEξ={∑i​xi​pi​ξ是离散型随机变量∫−∞−∞​xp(x)dxξ是连续型随机变量​\nEY={∑i​f(xi​)pi​ξ是离散型随机变量∫−∞−∞​f(x)p(x)dxξ是连续型随机变量​\nEc=c\nE(aξ1​+bξ2​)=aEξ1​+bEξ2​\nξη独立，Eξη=EξEη，反之未必\n方差 §\nD(ξ)=E(ξ−Eξ)2\nDξ=σ2σ=Dξ​​\n称σ为标准差\nDξ=Eξ2−(Eξ)2\nDc=0\nD(aξ+b)=a2Dξ\nCmin​E(ξ−C)2=E(ξ−Eξ)2=Dξ\nD(X+Y)=D(X)+D(Y)+2E{[X−E(X)][Y−E(Y)]}\nKi​=E[(ξi​−Eξi​)(ξj​−Eξj​)]\nD(i=1∑n​ξi​)=i=1∑n​Dξi​+21≤i&lt;j≤n∑​Kij​\n当XY独立时，\nD(X+Y)=D(X)+D(Y)\n若ξ相互独立，则\nD(i=1∑n​ξi​)=i=1∑n​Dξi​\n标准化 §\nξ∗=Dξ​ξ−Eξ​\n使得ξ*的期望为0，方差为1\n切比雪夫不等式 §\nP(∣ξ−Eξ∣≥ϵ)≤ϵ2Dξ​​\n协方差 §\ncov(ξ,η)=E([ξ−E(ξ)][η−E(η)])\ncov(ξ,η)=Eξη−(Eξ)⋅(Eη)\n协方差是反映两个随机变量X,Y之间线性相关程度的数字特征。\n 当Cov(X,Y) &gt; 0, 称X与Y 正相关；\n 当Cov(X,Y) &lt; 0, 称X与Y 负相关；\n 当Cov(X,Y) = 0, 称X与Y 不相关；\n协方差是有量纲的数字特征\ncov(aξ+bη,ζ)=acov(ξ,ζ)+bcov(η,ζ)\n若ξ ,η独立,且它们的协方差存在，则协方差必为0 .但反之未必\n不相关 §\n若随机变量ξ和η独立，则ξ和η不相关\n等价命题有\n​Cov(ξ,η)=0ρξη​=0Eξη=EξEηD(ξ+η)=Dξ+Dη​\n相关系数 §\nρξη​=DξDη​Cov(ξ,η)​​\nρξη​=Cov(ξ∗,η∗)\n相关系数无量纲\n简单随机抽样\n独立同分布，i.i.d.\n统计量 §\n设(X1,X2,…,Xn)是取自总体ξ 的一个样本 , 称不含有未知参数的样本的函数T=T(X1,X2,…,Xn)为统计量\n样本均值 §\nX=n1​i=1∑n​Xi​\nE(X)=μ\nD(X)=nσ2​\n样本方差 §\nSn−12​=n−11​i=1∑n​(Xi​−X)2\nE(Sn−12​)=σ2\n样本标准差 §\nσn−1​=Sn−1​=n−11​i=1∑n​(Xi​−X)2​\n样本k阶原点矩 §\nXk=n1​i=1∑n​Xik​\n矩法原则 §\n样本2阶中心矩 §\n常用统计量结论 §\n设(X1,X2,…,Xn)是取自正态总体N(μ,σ2)的样本\n样本均值和样本方差相互独立\nX∼N(μ,nσ2​)\nσ2(n−1)Sn−12​​∼χ2(n−1)\nSn−1​/n​X−μ​∼t(n−1)\n分位数 §\n称满足\nP{T≤t1−α​}=1−α\n的t(1-a)为下分位数\n此处T指代t分布\n\n抽样分布 §\n卡方分布 §\nX1,X2,…,Xn独立同分布N(0,1)\nX=i∑n​Xi2​∼χ2(n)\n性质 §\nEX=n\nDX=2n\nXκ(n1),Yκ(n2),X与Y相互独立，则X+Y~κ(n1+n2)\nn→∞时，卡方分布趋向于正态分布\nt分布 §\n设XN(0,1),Yκ(n),X，Y相互独立\nT=nY​​X​\n称T服从自由度为n的T分布，记作t(n)\n性质 §\n密度函数是偶函数\nn→∞时，卡方分布趋向于标准正态分布\nF分布 §\nXκ(m),Yκ(n),X与Y相互独立，\nF=Y/nX/m​\n称F服从为第一自由度为m，第二自由度为n的F分布。记作F~F(m,n)\n性质 §\nFF(m,n)，则1/FF(n,m)\nF1−α​​(m,n)=Fα​​(n,m)1​\n点估计 §\n设总体X的分布函数的形式已知,但含有一个或多个未知参数θ\n设 X 1 , X 2 ,…, X n 为总体的一个样本(容量n),\n构造 k 个统计量（都是随机变量）：\nθ^1​(X1​,X2​,⋯,Xn​)θ^2​(X1​,X2​,⋯,Xn​)⋯θ^k​(X1​,X2​,⋯,Xn​,​⎭⎬⎫​\n作为θ的估计量\n当测得样本值(x 1 , x 2 ,…, x n ) 时, 代入上述统计量，即可得到 k 个数，作为θ的估计值\n矩估计 §\n用样本 k 阶矩作为总体 k 阶矩的估计量, 建立含有待估参数的方程, 从而解出待估参数\n\n求出带有未知参数的 总体矩\n令 样本矩 等于总体矩, 方程组个数与未知参数个数相同\n解出未知参数\n\n尽量使用低阶矩\n可能得到不合理的解\n总体矩不一定存在，可能会有不同的矩估计\n正态分布矩法估计量\nμ^​=X\nσ^2=n1​i=1∑n​Xi2​−X2\n指数分布矩法估计量\nλ^=X1​\n泊松分布矩法估计量\nλ^=X\n极大似然估计 §\n一般来说，若事件A 发生的概率与参数θ∈Θ有关，θ取值不同，P(A)也不同，则应记事件A发生的概率为 P(A|θ). 若一次试验，事件A发生了，可认为此时的θ值 应该是在Θ中使P(A|θ)达到最大的那一个。称P(A|θ)为似然函数。\n似然函数 §\nX 1 ,X 2 , …,X n 是取自总体X的样本,x 1 , x 2 , …, x n 是样本值\n以离散型为例\n分布律 其中θ为待估参数\nP{ξ=x}=p(x,θ1​,θ2​,⋯θk​)\n联合分布律\n​P{X1​=x1​,X2​=x2​,⋯,Xn​=xn​}=p(x1​,θ1​,θ2​,⋯θk​)p(x2​,θ1​,θ2​,⋯θk​)⋯p(xn​,θ1​,θ2​,⋯θk​)=i=1∏n​p(xi​,θ1​,θ2​,⋯θk​)​\n有似然函数\nL(θ)=i=1∏n​p(xi​,θ1​,θ2​,⋯,θk​)\n极大似然估计法 §\n选择适当的θhat=θ,使似然函数或似然函数的对数值最大\n称这样得到的\nθ^=g(X1​,X2​,⋯,Xn​)\n为参数θ的极大似然估计量\n称这样得到的\nθ^=g(x1​,x2​,⋯,xn​)\n为参数θ的极大似然估计值\n正态分布极大似然估计量\nμ^​=X\nσ^2=n1​i=1∑n​Xi2​−X2=Sn2​\n泊松分布极大似然估计量\nλ^=X\n极大似然估计的不变性\n点估计的评价 §\n无偏性 §\nE(θ^)=θ\n样本矩是总体矩的无偏估计量\n样本方差是总体方差的无偏估计量\n有效性 §\nθ的两个无偏估计量\nD(θ1​^​)≤D(θ2​^​)\nθ1hat更有效\n在所有线性无偏估计中，样本均值是最有效的\n相合性 §\nn是样本容量，对任意ε&gt;0\nn→∞lim​P{∣θ^−θ∣&lt;ε}=1\n矩法估计都是相合估计\n大多数极大似然估计是相合估计\n区间估计 §\n设θ是总体的一个参数, 其参数空间为 Θ，(X1,X2,…,Xn)是总体的一个样本。若对于事先给定的α，存在\nθL​^​=θL​^​(X1​,X2​,⋯Xn​)\nθU​^​=θU​^​(X1​,X2​,⋯Xn​)\n满足对任意的θ∈Θ，成立概率估计式：\nP{θL​^​≤θ≤θU​^​}=1−α\n则称该随机区间为 θ 的 置信水平 为 1- α的置信区间\n意义如下图\n\n求参数θ置信区间\n寻找一个样本的函数g(X1,X2,…,Xn,θ)，称为枢轴量\n它含有待估参数, 但不含其它未知参数. 它的分布已知, 且分布不依赖于待估参数 ( 常由θ的点估计出发考虑）\n给定置信度1-α,定出常数 a , b ,使得\nP{a≤g(X1​,X2​,⋯,Xn​,θ)≤b}=1−α\n由\na≤g(X1​,X2​,⋯,Xn​,θ)≤b\n解出置信区间\n已知σ，求μ的置信区间\n设总体~N(μ,σ2)，其中σ已知，求μ的置信水平为1-α的置信区间\nU=σX−μ​∼N(0,1)\nP{​σX−μ​n​​≤U1−2α​​}=1−α\n解出置信区间为\n[X−U1−2a​n​​,X+U1−2a​n​​]"},"求积":{"title":"求积","links":[],"tags":[],"content":"积分中值定理\n∫ab​f(x)dx=(b−a)f(ξ)\n依据选择的平均高度有\n梯形公式\nI≈2b−a​[f(a)+f(b)]\n选取\nf(ξ)=21​[f(a)+f(b)]\nSimpson公式\nI≈6b−a​[f(a)+4f(2a+b​)+f(b)]\n选取\nf(ξ)=61​[f(a)+4f(c)+f(b)]\n更具一般性的情况\n机械求积\n∫ab​f(x)dx≈(b−a)i=0∑n​λi​f(xi​)\n求积公式的代数精度\nm阶精度，满足次数≤的幂函数\n(b−a)i=0∑n​λi​xik​=∫ab​xkdx,k=0,1,⋯,m\n问题也即求解如下形式的代数方程组\ni=0∑n​λi​xik​=b−a1​⋅k+1bk+1−ak+1​k=0,1,⋯,m\n将求积区间变为[-1,1]\nx=2b+a​+2b−a​t\n∫ab​f(x)dx=2b−a​∫−11​f(2b+a​+2b−a​t)dt\ng(t)=f(2b+a​+2b−a​t)\n∫−11​g(t)dt≈2i=0∑n​λi​g(ti​)\n由于幂函数在对称区间的特性，只须满足\ni=0∑n​λi​tik​={k+11​,k为偶数0,k为奇数​\nNewton-Cotes公式 §\n将求积区间n等分，选取等分点\nxi​=a+ih,h=nb−a​,i=0,1,⋯,n\n若至少有n阶精度，称为n阶Newton-Cotes公式\n一阶Newton-Cotes公式即梯形公式\n三阶Newton-Cotes公式即Simpson公式\n五阶Newton-Cotes公式即Cotes公式\nI=90b−a​[7f(x0​)+32f(x1​)+12f(x2​)+32f(x3​)+7f(x4)]\n\n当区间等分数n为偶数时，Newton-Cotes公式具有n+1阶精度。\n当区间等分数n为奇数时，Newton-Cotes公式具有n阶精度。\n当n≤7时，lambda均大于0，误差数值稳定\n反之，lambda有正有负\nGauss公式 §\n适当选取x和lambda，可具有2n+1阶精度\n系数均非负，稳定的\n当求积区间为[-1,1]时\n一点Gauss公式\nG1​=2f(0)\nG1​=(b−a)f(2a+b​)\n两点Gauss公式\nG2​=f(−3​1​)+f(3​1​)\nG2​=2b−a​[f(2b+a​−23​b−a​)+f(2b+a​+23​b−a​)]\n三点Gauss公式\nG3​=95​f(−53​​)+98​f(0)+95​f(53​​)\nG3​=2b−a​[95​f(2b+a​−53​​2b−a​)+98​f(2b+a​)+95​f(2b+a​+53​​2b−a​)]\n复化求积\n分段求积\nxi​=a+ih,h=nb−a​,i=0,1,⋯,n\n复化梯形公式\nTn​=i=0∑n−1​2h​[f(xi​)+f(xi+1​)]=2nb−a​[f(a)+2i=0∑n−1​f(xi​)+f(b)]​\n数值稳定的\n复化Simpson公式\nSn​​=i=0∑n−1​6h​[f(xi​)+4f(xi+21​​)+f(xi+1​)]=6nb−a​[f(a)+4i=o∑n−1​f(xi+21​​)+2i=1∑n−1​f(xi​)+f(b)]​\n数值稳定的\n复化Cotes公式\nCn​=90nb−a​[7f(a)+32i=0∑n−1​f(xi+41​​)+14i=o∑n−1​f(xi−21​​)+32i=0∑n−1​f(xi+43​​)+7f(b)]\n变步长梯形法\n将积分区间n等分时共有n+1个分点，2n等分时共有2n+1个分点，其中的计算应当可以共享，以下研究\n在任意一个子区间中\nT1,i​=2h​[f(xi​)+f(xi+1​)]\nT2,i​=4h​[f(xi​)+2f(xi+21​​)+f(xi+1​)]\nT2,i​=21​T1,i​+2h​f(xi+21​​)\n故\nT2n​=21​Tn​+2h​i=0∑n−1​f(xi+21​​)\nh为二分前的步长\nh=nb−a​\n\nRomberg\n\nTm(k)​=4m−14mTm−1(k+1)​−Tm−1(k)​​\nT0,T1,T2,T3分别是梯形值，辛普森值，柯特斯值，龙贝格\n精度为m的两倍，收敛阶为m+1的两倍"},"算法":{"title":"算法","links":["动态规划"],"tags":["算法"],"content":"排序\n二分 §\n\n细节1：l初始化为-1,r初始化为数组长度n\n细节2：m始终处于[0,n)\n细节3：不会死循环(l+1=r,l+2=r…)\nl = -1,r = N;\nwhile(l + 1 != r){\n\tm = (l + r) / 2;\n\tif(isBlue(m)) l = m;\n\telse r = m;\n}\nreturn l or r;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIsBlue()条件返回第一个&gt;=x&lt;xr最后一个&lt;x&lt;xl第一个&gt;x&lt;=xr最后一个&lt;x&lt;=xl\n整数二分\n边界一定存在，但边界不一定是原问题的解\n浮点二分\n快速排序\nvoid quick_sort(int q[], int l, int r)\n{\n    if (l &gt;= r) return;\n\tint i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];\n    while (i &lt; j)\n    {\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] &gt; x);\n        if (i &lt; j) swap(q[i], q[j]);\n    }\n    quick_sort(q, l, j), quick_sort(q, j + 1, r);\n}\n如何使得x左侧都小于等于 右侧都大于等于\n1.开两个新数组分别存再拷回来 同样是O(N)\n2.双指针\n注意选择以i分治时不能取x[l] j时不能[r] 容易边界问题 反例{1 2}\n中间元素取l+r+1/2和不加1\ni-1 i/j j+1对于i指针 指针停的位置是大于等于x的 之前的是小于等于x的\n快速排序如何变成稳定的 将索引也纳入\n归并排序\nvoid merge_sort(int q[], int l, int r)\n{\n    if (l &gt;= r) return;\n    int mid = l + r &gt;&gt; 1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n \n    int k = 0, i = l, j = mid + 1;\n    while (i &lt;= mid &amp;&amp; j &lt;= r)\n        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];\n        else tmp[k ++ ] = q[j ++ ];\n \n    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];\n    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];\n \n    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];\n}\n高精度加法\n高精度减法\n高精度乘法\n高精度除法\n前缀和 §\nO(1)区间查询\n一维\ns[i]=a[1]+a[2]+...+a[i]s=s[r]−s[l−1]\n二维\ns[i][j]=s[i−1][j]+s[i][j−1]−s[i−1][j−1]+a[i][j]s=s[i2][j2]−s[i1−1][j2]−s[i2][j1−1]+s[i1−1][j1−1]​\n差分 §\nO(1)区间修改（加减某个数）\np[i]=a[i]−a[i−1]\np[i]+c则a[i...n]+c\n因此，为了使区间[L,R]中的所有元素+c，只需p[l]+c p[r+1]-c\na[i]=p[1]+p[2]+...+p[i]\n二维\np[i][j]=a[i][j]−a[i−1][j]−a[i][j−1]+a[i−1][j−1]\n因此，为了使区间[L,R]中的所有元素+c，只需p[x1][y1]+c p[x2+1][y]-c p[x1][y2+1]-c p[x2+1][y2+1]+c\n树状数组 §\nO(logn)单点修改，区间查询\ntree[x]存储[x-lowbit(x)+1,x]中数的和，x的父节点是x+lowbit(x)\nvoid update(int x,int d){\n\twhile (x&lt;N){\n\t\ttree[x]+=d;\n\t\tx+=lowbit[x];\n\t}\n}\n \nint sum(int x){\n\tint ans = 0;\n\twhile (x&gt;0){\n\t\tans+=tree[x];\n\t\tx-=lowbit[x];\n\t}\n}\n \n将树状数组中保存的值运用差分，即可变为区间修改，单点查询\n//区间修改\nupdate(L,x);\nupdate(R+1,-x);\n \nsum(i) //单点查询\nST算法 §\nO(1)区间最值查询\ndp[s][k]左端点为k，区间长度为2^k的区间最值\ndp[s][k]=min(dp[s][k-1],dp[s+1&lt;&lt;(k-1)][k-1])\n区间[L,R]的最值为min(dp[L][k], dp[R-(1&lt;&lt;k)+1][k]，k为比区间长度小的最大的2的倍数\n线段树 §\n区间修改涉及到懒惰修改，tag数组意味着未向子树传递的更新量。\nvoid build(int p,int pl,int pr){\n\tif(pl==pr){\n\t\ttree[p]=a[pl];\n\t\treturn;\n\t}\n\tint mid = (pl + pr) &gt;&gt; 1;\n\tbuild(ls(p),pl,mid);\n\tbuild(rs(p),mid+1,pr);\n\ttree[p] = tree[ls(p)] + tree[rs(p)];//\n}\n \n \n//query(L,R,1,1,n)\nint query(int L,int R,int p,int pl,int pr){\n\tif (l&lt;=pl&amp;&amp;pr&lt;=r){\n\t\treturn tree[p];\n\t}\n\tpush_down(p, pl, pr);\n\tint mid = (pl + pr) &gt;&gt; 1;\n\tint res = 0;\n\tif (L&lt;=mid) res += query(L,R,ls(p),pl,mid);//\n\tif (R&gt;=mid+1) res += query(L,R,rs(p),mid+1,pr);//\n\treturn res;\n}\n \nvoid update(int p,int pl,int pr,int x,int k){\n\tif(pl==x&amp;&amp;pr==x){\n\t\ttree[p]+=k;\n\t\treturn;\n\t}\n\tint mid = (pl + pr) &gt;&gt; 1;\n\tif(x&lt;=mid) update(ls(p),pl,mid,x,k);\n\tif(x&gt;=mid+1) update(rs(p),mid+1,pr,x,k);\n\ttree[p] = tree[ls(p)] + tree[rs(p)];//\n}\n \nvoid update(int L, int R, int p, int pl, int pr, int d){\n\tif (L &lt;= pl &amp;&amp; R &gt;= pr){\n\t\taddtag(p, pl, pr, d);\n\t\treturn;\n\t}\n\tpush_down(p, pl, pr);\n\tint mid = (pl + pr) &gt;&gt; 1;\n\tif (L &lt;= mid) update(L, R, ls(p), pl, mid, d);\n\tif (R &gt;= mid + 1) update(L, R, rs(p), mid + 1, pr, d);\n\ttree[p] = tree[ls(p)] + tree[rs(p)];//\n}\nvoid push_down(int p, int pl, int pr){\n\tif(tag[p]){\n\t\tint mid = (pl + pr) &gt;&gt; 1;\n\t\taddtag(ls(p),pl,mid,tag[p]);\n\t\taddtag(rs(p),mid+1,pr,tag[p]);\n\t\ttag[p]=0;\n\t}\n}\nvoid addtag(int p,int pl, int pr,int d){\n\ttag[p]+=d;\n\ttree[p]+=d*(pr-pl+1);\n}\n双指针 §\nfor (int i = 0, j = 0; i &lt; n; i ++ ){\n    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;\n    // 具体问题的逻辑\n}\n位运算 §\n求n的二进制表示中第k位（个位为第0位）\nn&gt;&gt;k&amp;1\nlowbit §\n返回二进制表达式中最低位的1所对应的值。\nx&amp;-x\n离散化 §\n保序 将值域很大但稀疏的数组映射\n// std::vector&lt;int&gt; a, b; // b 是 a 的一个副本 并用b来存储离散化结果\nstd::sort(a.begin(), a.end());\na.erase(std::unique(a.begin(), a.end()), a.end());\nfor (int i = 0; i &lt; n; ++i)\n  b[i] = std::lower_bound(a.begin(), a.end(), b[i]) - a.begin();\n \n并查集 §\n路径压缩 按秩合并O(logn)\nint find(int x){\n\tif(x != p[x]) p[x] = find(p[x]);\n\treturn p[x];\n}\n \nvoid merge_set(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x != y) p[x] = p[y];\n}\n节点到根的关系 关系具有传递性 可以方便求出节点之间关系\n单调队列/栈\n先加入且性质更差的一定不会被输出\n连通集 §\n单链表\n插入 删除 遍历 建立\n单链表逆转\n每次将旧链表的头插入到新链表（即已经倒转的链表）的尾端 直至旧链表为空（循环不变式）\n邻接表\n双链表 双向循环链表\n栈\n顺序存储实现\nTop指向栈顶前一个结点（仍存在）\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;stdbool.h&gt;\n#define ERROR -1\ntypedef int Position;\ntypedef struct SNode* PtrToSNode;\nstruct SNode\n{\n    int* Data;\n    Position Top;\n    int maxCount;\n};\ntypedef PtrToSNode Stack;\nStack CreateStack(int maxCount){\n    Stack S = (Stack)malloc(sizeof(struct SNode));\n    S-&gt;Data = (int *)malloc(maxCount * sizeof(int));\n    S-&gt;Top = -2;\n    S-&gt;maxCount = maxCount;\n    return S;\n}\n \nbool IsFull(Stack S){\n    return S-&gt;Top + 2 == S-&gt;maxCount;\n}\nbool IsEmpty(Stack S){\n    return S-&gt;Top + 2 == 0;\n}\nbool AddQ(Stack S,int x){\n    if(IsFull(S)){\n        printf(&quot;堆栈满\\n&quot;);\n        return false;\n    }\n    else{\n        S-&gt;Top++;\n        S-&gt;Data[S-&gt;Top + 1] = x;\n        return true;\n    }\n}\nint DeleteQ(Stack S){\n    if(IsEmpty(S)){\n        printf(&quot;堆栈空\\n&quot;);\n        return ERROR;\n    }\n    else{\n        S-&gt;Top--;\n        return S-&gt;Data[S-&gt;Top + 2];\n    }\n}\n队列\n顺序存储实现\nFront指向队头的前一个结点（已被删除）\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;stdbool.h&gt;\n#define ERROR -1\ntypedef int Position;\ntypedef struct QNode* PtrToQNode;\nstruct QNode\n{\n    int* Data;\n    Position Front;\n    int Count;\n    int maxCount;\n};\ntypedef PtrToQNode Queue;\nQueue CreateQueue(int maxCount){\n    Queue Q = (Queue)malloc(sizeof(struct QNode));\n    Q-&gt;Data = (int *)malloc(maxCount * sizeof(int));\n    Q-&gt;Front = Q-&gt;Count = 0;\n    Q-&gt;maxCount = maxCount;\n    return Q;\n}\n \nbool IsFull(Queue Q){\n    return Q-&gt;Count == Q-&gt;maxCount;\n}\nbool IsEmpty(Queue Q){\n    return Q-&gt;Count == 0;\n}\nbool AddQ(Queue Q,int x){\n    if(IsFull(Q)){\n        printf(&quot;队列满\\n&quot;);\n        return false;\n    }\n    else{\n        Q-&gt;Count++;\n        Q-&gt;Data[(Q-&gt;Front + Q-&gt;Count) % Q-&gt;maxCount] = x;\n        return true;\n    }\n}\nint DeleteQ(Queue Q){\n    if(IsEmpty(Q)){\n        printf(&quot;队列空\\n&quot;);\n        return ERROR;\n    }\n    else{\n        Q-&gt;Front = (Q-&gt;Front + 1) % Q-&gt;maxCount;\n        Q-&gt;Count--;\n        return Q-&gt;Data[Q-&gt;Front];\n    }\n}\n前缀函数 §\nπ[i]表示在子串s[0...i]中最长相等的真前缀和真后缀的长度(真 意为 不包括子串自身) i取[0,n-1]\n规定π[0]=0\n计算 §\n第一个重要观察 相邻的前缀函数值至多增加1\n π[i+1]=4s0​ s1​ s2​​ π[i]=3​s3​​​ …  π[i+1]=4 si−2​ si−1​ si​​π[i]=3​ si+1​​​\n当s[i+1]=s[π[i]]时，π[i+1]=π[i]+1\n第二个重要观察\njs0​s1​​​s2​s3​​π[i]​…si−3​si−2​jsi−1​si​​​​π[i]​si+1​\n失配时希望找到仅次于π[i]的长度j继续匹配，初始化j=π[i]，迭代j=π[j-1]\nvector&lt;int&gt; prefix_function(string s) {\n  int n = (int)s.length();\n  vector&lt;int&gt; pi(n);\n  for (int i = 1; i &lt; n; i++) {\n    int j = pi[i - 1];\n    while (j &gt; 0 &amp;&amp; s[i] != s[j]) j = pi[j - 1];\n    if (s[i] == s[j]) j++;\n    pi[i] = j;\n  }\n  return pi;\n}\nKMP §\n//求next数组=前缀表-1\nint j = -1;\nne[0] = j;\nfor (int i = 1; i &lt; m; i++) {\n    while (j != -1 &amp;&amp; p[i] != p[j + 1]) j = ne[j];\n    if (p[i] == p[j + 1]) j++;\n    ne[i] = j;\n}\n// 匹配\nfor (int i = 0, j = -1; i &lt; n; i++) {\n    while (j != -1 &amp;&amp; s[i] != p[j + 1]) j = ne[j];\n    if (s[i] == p[j + 1]) j++;\n    if (j == m - 1) {\n        // 匹配成功后的逻辑\n        j = ne[j];\n    }\n}\ni j指针都到底时算法必定结束 i移动m次 而j最多移动m次 O(n)\nnext[i] 表示 前i个字符中使得前k个字符恰等于后k个字符的最大的k. 特别地，k不能取i（此时自己与自己相等无意义了）上面代码里的统一减一\n如何找到字符串中所有前后缀相等的\ni1=next[n] i2=next[i1]…\n字符串循环节n-next[n]\ntrie树 §\n又称字典树，是一种状态机\n \nstruct trie {\n//N为节点上限数，son为每个节点的指针域（共26个分支），cnt为每个节点的数据域，idx为当前总节点数\n  int nex[N][26], idx, int cnt[N];\n  void insert(char *s, int l) {\n    int p = 0;\n    for (int i = 0; i &lt; l; i++) {\n      int c = s[i] - &#039;a&#039;;\n      if (!nex[p][c]) nex[p][c] = ++idx;\n      p = nex[p][c];\n    }\n    cnt[p]++;\n  }\n \n  int query(char *s, int l) {\n    int p = 0;\n    for (int i = 0; i &lt; l; i++) {\n      int c = s[i] - &#039;a&#039;;\n      if (!nex[p][c]) return 0;\n      p = nex[p][c];\n    }\n    return cnt[p];\n  }\n};\n \n并查集\n堆\n哈希\n字符串哈希\n预处理出所有前缀的哈希\n字符串看作P进制数\n线性表\n顺序存储实现和链式存储实现\n图论 §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n算法单源/多源存在负权边时间复杂度朴素Dijkstra单否O(n^2)堆优化D~单否O(mlogn)Bellman-Ford单是O(nm)SPFA单是一般O(m)Floyd多是O(n^3)\nDijkstra\n贪心 每次确定一个到起点距离最近的点 用它更新其他点（到初始点）的距离和前驱 将该点加到集合中 迭代n次\nbellman-ford算法\n循环n次，每次循环遍历所有边更新距离(备份 只使用上一轮循环的结果更新)\n循环k次得到经过不超过k条边的最短距离\n循环n次时若更新则必有经过n条边的最短距离 n条边 n+1个点 若n+1&gt;点的个数则存在环且负环\nspfa\n只有以距离更新变小的点为起点的边的终点距离也会变小，只更新这些点，维护队列且保证队列元素不重复\n维护最短距离对应边数，边数大于等于n时，n+1个点，负环\nspfa中无法到达n号点则不会更新距离，而bellman会\nFloyd\nfor (int k = 1; k &lt;= n; k++){\n    for (int i = 1; i &lt;= n; i++){\n        for (int j = 1; j &lt;= n; j++){\n        \td[i][j] = min(d[i][k] + d[k][j], d[i][j]);\n        }\n    }\n}\nPrim\n朴素O(n^2) 堆优化O(mlogn)\n每次确定一个到集合距离最近的点 用它更新其他点（到集合）的距离和前驱 将该点加到集合中 迭代n次\nKruskal O(mlogm)\n将所有边按照权重排序，枚举边，边不连通则连通\n染色法O(n+m)\n不含奇数（边）环则可二分\n匈牙利算法O(nm),实际远小  难点\n在目前匹配情况下没有搜索到以该点开始的增广路径则加入后面的点也不会有以该点开始的增广路径\n存在增广链是增广当前匹配的充要条件\nbool find(int x){\n    //遍历出边\n    for (int i = h[x]; i != -1;i=ne[i]){\n        int j = e[i];\n        if(!st[j]){\n            st[j] = true;\n            if(match[j]==0||find(match[j])){\n                match[j] = x;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfor (int i = 1; i &lt;= n1;i++){\n    memset(st, false, sizeof(st));\n    if(find(i)) res++;\n}\n数学 §\n逆序对 §\n求逆序对数量\n将数组元素看作树状数组的下标\n1.逆序做法\n将a[i]+1，将sum[i-1]加到结果中\n也就是统计了出现在一个元素之后比它小的元素\n2.正序做法\n将a[i]+1，将已经处理的数的个数-sum[i-1]加到结果中\n也就是统计了出现在一个元素之前比它大的元素\n快速幂 §\nlong long binpow(long long a, long long b) {\n  long long res = 1;\n  while (b &gt; 0) {\n    if (b &amp; 1) res = res * a;\n    a = a * a;\n    b &gt;&gt;= 1;\n  }\n  return res;\n}\n矩阵快速幂 §\n此处为2x2矩阵\nstruct Matrix {\n  int a[3][3];\n \n  Matrix() { memset(a, 0, sizeof a); }\n \n  Matrix operator*(const Matrix &amp;b) const {\n    Matrix res;\n    for (int i = 1; i &lt;= 2; ++i)\n      for (int j = 1; j &lt;= 2; ++j)\n        for (int k = 1; k &lt;= 2; ++k)\n          res.a[i][j] += a[i][k] * b.a[k][j];\n    return res;\n  }\n} ans, base;\n \n \nMatrix qpow(Matrix base, int b) {\n  Matrix ans;\n  while (b) {\n    if (b &amp; 1) ans = ans * base;\n    base = base * base;\n    b &gt;&gt;= 1;\n  }\n}\n质数\n试除法 §\nO(sqrt(n))\n合数的约数成对出现 判断是不是质数只需判断较小的数能否整除n\n而d|n则(n/d)|n,令d&lt;=(n/d)则d&lt;=sqrt(n)\n用i&lt;=x/i判断而不是i*i&lt;=x（溢出）或i&lt;=sqrt(x)（慢）\nbool is_prime(int x)\n{\n    if (x &lt; 2) return false;\n    for (int i = 2; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n            return false;\n    return true;\n}\n分解质因数 §\n一个合数分解而成的质因数最多只包含一个大于sqrt(x)的质因数\n枚举所有小于等于sqrt(x)的数i，将原数中该数的因子i除干净。当枚举到i时,n的因子不包括2到i-1中的数，若i|n,则i的因子不包括2到i-1的数，则i一定是质数\nvoid divide(int x)\n{\n    for (int i = 2; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n        {\n            int s = 0;\n            while (x % i == 0) x /= i, s ++ ;\n            printf(&quot;%d %d\\n&quot;, i, s);\n        }\n    if (x &gt; 1) printf(&quot;%d 1\\n&quot;, x);\n    printf(&quot;\\n&quot;);\n}\nO(sqrt(n))\n朴素筛法 §\n枚举所有数，将该数的倍数筛掉 同上，当枚举到i时，没有被2到i-1筛掉 不是这些数的倍数 该数为质数\n复杂度O(nlogn)\n埃氏筛法 §\n枚举所有数，只将所有质数的倍数筛掉 复杂度O(nloglogn)\n质数定理：1-n中有n/lnn个质数\n线性筛法 §\n将每个数只用它的最小质因数筛掉\n枚举所有数i 若i没有被筛则记录为素数，再对i从小到大枚举质数p[j]（p[j]&lt;=i）\n若p[j]不|i，则p[j]一定小于i的所有质因子，p[j]也一定是p[j]*i的最小质因子\n若（第一次找到）p[j]|i,则p[j]是i的最小质因子，p[j]也一定是p[j]*i的最小质因子\n对合数x,假设p[j]是x的最小质因子，当枚举到x/p[j]（有x/p[j]&gt;p[j]且x/p[j]的最小质因数大于等于p[j]）时被删除\n每个合数都会被筛，只用最小质因子筛，每个合数一定有最小质因子\nvoid get_primes(int n)\n{\n    for (int i = 2; i &lt;= n; i ++ )\n    {\n        if (!st[i]) primes[cnt ++ ] = i;\n        for (int j = 0; primes[j] &lt;= n / i; j ++ )//保证p[j]*i在n范围内\n        {\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\n约数个数 §\nN=P1α1​P2α2​...Pkαk​num=(α1+1)(α2+1)...(αk+1)\n约数之和 §\nN=P1α1​P2α2​...Pkαk​sum=(P10​+P11​+...P1α1​)(P20​+P21​+...P2α2​)...(Pk0​+Pk1​+...Pkαk​)\n辗转相除法 §\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n证明 §\n已知两个数a和b\n不妨设a&gt;b\n如果b|a，那么b就是二者的最大公约数。 下面讨论不能整除的情况，\n由模的性质，d|a d|b则d|ax+by\n而a mod b=a-kb\n若d|a d|b则d|a mod b,反之若d|b d|a mod b,则d|a\n则有a,b的公约数等价于b,a mod b的公约数，那么最大公约数应该也相同\n有==gcd(a,b)=gcd(b,a mod b)==\n辗转相除到最后发生gcd(a’,b’),而b’|a’（进一步，下一层递归调用为gcd(b’,0)），则b’为a’，b’的最大公约数，一路等价\n欧拉函数\n1-n中与n互质的数的个数\n公式\nN=P1α1​P2α2​...Pkαk​ϕ(N)=N(1−P1​1​)(1−P2​1​)...(1−Pk​1​)​\n容斥原理，先去除单个质因子的倍数，再加上任意两个质因子的组合的倍数，再减去…上述多项式展开系数符合该规律\n筛法求欧拉函数\n在线性筛法中,若i mod p[j]=0,p[j]是i的最小质因子,则有\nϕ(p[j]∗i)=ϕ(i)∗p[j]\n若i mod p[j]!== ,p[j]不是i的质因子,则有\nϕ(p[j]∗i)=ϕ(i)∗p[j]∗(1−p[j]1​)\n欧拉定理 若a与n互质,\naϕ(n)≡1(modn)\n费马小定理 质数p a不是p的倍数 则\nap−1≡1(modn)\n快速幂\nO(logk)\na的k次方模p k以二进制表示，预处理出a的2的0到logk次方的模\na2log2​k=a2log2​k−1∗2=(a2log2​k−1)2\n求逆元\n若b与m互质，存在x使得\na/b≡ax(modm)\n称x为b的模m乘法逆元，存在b的乘法逆元的充要条件是b与m互质\na/b≡ab−1(modm)a≡ab−1b(modm)bb−1≡1(modm)\n当m为质数时\nbbm−2≡1(modm)\n扩展欧几里得算法 §\n裴蜀定理\n不全为0的整数a,b,存在整数x,y使得ax+by=gcd(a,b)\ngcd(b,a mod b)=gcd(a,0)=a，对于后式取x=1,y=0即为解\nbx+(a mod b)y=a\nay+b(x-(a\\b)y)=a这样得到a，b的一组解\n⎩⎨⎧​x=x0​−gcdb​ky=y0​+gcda​k​\nint exgcd(int a, int b, int&amp; x, int&amp; y)\n{\n    if (!b)\n    {\n        x = 1, y = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n线性同余方程 §\nax≡b(modm)即存在y使得ax=my+bax−my=b\n给定a,m,b\nb是gcd(a,m)的倍数时可以由裴蜀定理求出\n若b不是,而等式左边是，则矛盾，无解\n中国剩余定理 §\nm1​,m2​,...,mk​两两互质x≡a1​(modm1​)x≡a2​(modm2​)x≡ak​(modmk​)M=m1​m2​...mk​Mi​=M/mi​Mi−1​表示Mi​模mi​的逆x=a1​M1​M1−1​+a2​M2​M2−1​+...+ak​Mk​Mk−1​\n组合数 §\n1.数据多 小，使用递推\nCab​=Ca−1b​+Ca−1b−1​\n2.数据数量中 大小中，预处理出阶乘\nCab​=(a−b)!b!a!​\n其中分母上的数使用逆元转化为乘法\n逆元的乘积等于乘积的逆元\n3.数据少 大，卢卡斯定理\nCab​≡Camodpbmodp​Ca/pb/p​(modp)\n容易证明\n(1+x)p≡1+xp(modp)\n将a,b以k进制表示\na=ak​pk+ak−1​pk−1+...+a0​p0b=bk​pk+bk−1​pk−1+...+b0​p0(1+x)a≡(1+xp0)a0​(1+xp1)a1​...(1+xpk)ak​对比xb的系数有Cab​≡Cak​bk​​Cak−1​bk−1​​...Ca0​b0​​\n4.数据极大 全部输出\n先将组合数分解质因数，每个质因子出现次数等于a!中出现减去b!和(a-b)!中出现次数\n计算n!中质因子p的次数=a\\p+a\\p^2+a\\p^3+…\n最后高精度乘法\n卡特兰数 §\n给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)\n将原问题转化为二维坐标系下0表示向右走,1表示向上走，则要求等价为不经过y=x+1运动到(n,n),总数为C(2n,n)-C(2n,n-1)\n动态规划 §\n动态规划\n搜索 §\nbfs-&gt;dijkstra 维护队列单调性 出队/入队时确定\n双向广搜 某一个方向搜索队列为空意味着起点终点不连通\nA*\n启发函数\n使用优先队列 保存起点到当前点的距离和当前点的距离到终点的估计距离 需要保证估计值小于等于真实值\n只有终点出队时保证是最小距离\n八数码 §\n操作不改变逆序对数量奇偶性，充分必要条件是 数量为偶数\n估计函数：当前状态中每个数与目标位置的曼哈顿距离之和\n第K短路 §\n估价函数：建反图，终点到每个点的距离\n第k次搜到终点\n单词接龙 §\n记录单词之间最短前后缀长度 相当与单词之间有一条边\n分成互质组 §\n不互质的数之间连边\nDFS\n剪枝 §\n优先选择（能使）选择数量少的 可行性剪枝 最优性剪枝 排除等效冗余\n数独 §\n用九位零一串表示某一行（或列 或九宫格）1-9能否填\n取行 列 九宫格的交集\n迭代加深 §\n答案在浅层区域 控制搜索区域 O(N)\nIDA* §\n估价函数\n\n\n\nWhen you are analyzing an algorithm or code for its computational complexity\nusing Big-O notation, you can ignore the primitive operations that would\ncontribute less-important factors to the run-time. Also, you always take the worst\ncase behavior for Big-O.\n\n长度最小子数组 移除元素 反转链表 删除倒数第n个结点 链表环\n枚举 §\n全排列 §\n时间复杂度O(n*n!)\n两种理解方式，落实到代码上一样\n1.依次枚举每一个数放在哪一个位置\n2.依次对于每个位置枚举放哪个数\n全子集 §\n\n组合枚举 §\ndef count_partitions(n, m):\n        &quot;&quot;&quot;用1到m的数构成n&quot;&quot;&quot;\n        if n == 0:\n            return 1\n        elif n &lt; 0:\n            return 0\n        elif m == 0:\n            return 0\n        else:\n            return count_partitions(n-m, m) + count_partitions(n, m-1)"},"线性方程":{"title":"线性方程","links":[],"tags":[],"content":"Crammer法则\n计算量：(n2-1)n!+n\nJacobi\n化为对角方程组\nxi&lt;k+1&gt;​=(bi​−j=1,j=1∑n​aij​xj&lt;k&gt;​)/aii​,i=1,2,⋯,n\nx(k+1)=−D−1(L+U)x(k)+D−1b\n终止条件：\nmax1&lt;i&lt;n​∣xi&lt;k+1&gt;​−xi&lt;k&gt;​∣\nGaussSeidel\nxi&lt;k+1&gt;​=(bi​−j=1∑i−1​aij​xj&lt;k+1&gt;​−j=i+1∑n​aij​xj&lt;k&gt;​)/aii​,i=1,2,⋯,n\nx(k+1)=−(D+L)−1Ux(k)+(D+L)−1b\n总体上效果更好，但有时反而发散\n迭代过程收敛性\n严格对角占优 §\n对角元素绝对值大于同行其他元素绝对值之和\n严格对角占优阵两个方法都收敛，对称正定的GS收敛\n超松弛迭代\n{x~i&lt;k+1&gt;​=(bi​−∑j=1i−1​aij​xj&lt;k+1&gt;​−∑j=i+1n​aij​xj&lt;k&gt;​)/aii​xi&lt;k+1&gt;​=ωx~i&lt;k+1&gt;​+(1−ω)xi&lt;k&gt;​​\nSOR法的收敛性\n必要条件 w∈(0,2)\n对称正定时，任意收敛\n严格对角占优时，w∈(0,1]时任意收敛\n高斯消元法\n须满足\nakk&lt;k&gt;​=0\n对角占优可以保证这一点\n对称且对角占优的矩阵的对角元素全是主元素\n计算量\n3n3​+n2−31​n\n在计算机上计算可能会严重失真\n选主元素的高斯消元法\n列主元一般够用\n矩阵分解方法 §\nn阶方阵A的1到n-1阶顺序主子式均不为0，则矩阵A存在唯一的LU分解\nDoolittle分解\nL1U\n​uij​=aij​−k=1∑i−1​lik​ukj​,j≥ilji​=(aji​−k=1∑i−1​ljk​uki​)/uii​,j&gt;i​\nCrout分解\nLU1\n​lij​=aij​−k=1∑j−1​lik​ukj​,j=1,2,⋯,iuij​=(aij​−k=1∑j−1​lik​ukj​)/lii​,j=i+1,i+2,⋯,n​\n三对角线性方程组\n满足\n⎩⎨⎧​∣b1​∣&gt;∣c1​∣&gt;0∣bi​∣≥∣ai​∣+∣ci​∣(i=2,3,⋯,n−1)∣bn​∣&gt;∣an​∣&gt;0​\n存在唯一LU分解\n追赶法\n比Gauss计算量小\n平方分解方法\n\n对称正定存在唯一L 对角元素均为正\nlij​=(aij​−k=1∑j−1​dk​lik​ljk​)/dj​,j=1,2,⋯,i−1di​=aii​−k=1∑i−1​dk​lik2​,i=1,2,⋯,n​\nCholesky\n对称，所有顺序主子式不为0，存在唯一分解\n不必选主元，算法稳定，计算量n3/6（比Gauss小）\nL1DL1T\n​d1​l21​⋮ln1​​u21​d2​⋮ln2​​⋯⋯⋱⋯​un1​un2​⋮dn​​​\n⎩⎨⎧​di​=aii​−∑k=1i−1​uik​lik​uij​=aij​−∑k=1j−1​uik​ljk​lij​=uij​/dj​​(i=1,⋯,n)(j=1,⋯,i−1(j=1,⋯,i−1)​)"},"组成原理":{"title":"组成原理","links":[],"tags":[],"content":"时钟周期\n时钟频率 主频\nCPI\nClock Cycles Per Instruction\n时钟周期数=CPI∗指令数\nIPC\n1/CPI\nMIPS\nMillion Instructions Per Second\nMIPS=CPU时间∗106指令数​=CPI主频MHz​\nCPU时间\nCPU时间=时钟周期数∗时钟周期\nMFLOPS\nMillion Floating-Point Operations Per Second\nMFLOPS=CPU时间∗106浮点运算指令数​\n变形补码\n符号位00表示正数，符号位11表示负数，定点小数模为4，定点整数模为2^(n+2) n为数值位数\n正溢出符号位变为01，负溢出符号位变为10\n移码\n常用偏移量为2^n\n字长为w 位移量为2^(w-1)\n\n移码在符号位加1变成补码，与补码符号位相反，数值位相同\n可以直接比较大小\n加法溢出的检测方法\n1.正正得负 负负得正\n2.符号位进位和最高数值位进位不同\n3.变形补码\n多位串行加法器\n\n将全加器串联\n溢出信号需要(2n+6)T\n可控加减法电路\n\n延迟增加3T\n先行进位加法器 §\nSi​=Xi​⊕Yi​⊕Ci​Ci+1​=Xi​Yi​+(Xi​⊕Yi​)Ci​\n记\nGi​=Xi​Yi​Pi​=Xi​⊕Yi​\nCi+1​=Gi​+Pi​Ci​\n四位 §\n\n计算G，P，3T\n由G，P计算C，2T\n由P，C计算S，3T\n共8T\n#\nC4​=G3​+P3​G2​+P3​P2​G1​+P3​P2​P1​P0​G0​+P3​P2​P1​P0​C0​\n十六位 §\n\n计算G，P，5T（按照四位时输出时的时间）\n由G，P计算C4，C8，C12，C16，2T\n由G，P，C计算S，5T\n共12T\n定点乘法运算\n符号确定 符号位异或\n数值确定\n∣P∣=i=1∑n​(Yi​∣x∣∗2−i)\nPi+1​=(Pi​+yn−i​∣x∣)2−1P0​=0"},"编译原理":{"title":"编译原理","links":[],"tags":[],"content":"T型\n左右分别是源语言和目标语言，下方是编译器自身实现语言\n%% T型有两种结合方式，一种是实现语言相同，目标语言对源语言\n一种是实现语言和源语言相同 %%\n目标语言和编译器实现语言都为机器语言，这种编译器可以和自身bootstrap\n可以将A语言实现的A2K编译器和H语言实现的A2H编译器结合得到H语言实现的A2K编译器，称为交叉编译器\n进一步，将A语言实现的A2K再和交叉编译器结合可以得到K语言实现的A2K编译器。至此，通过K语言实现的A2K编译器，成功借助现有编译器将A语言编译到了K语言平台\n一个简单的递归下降\n只支持 只有一种分解情况正确返回的情况\nPredictive Parser\n向后看若干个token，不需要回溯\n需要接受LL(k)语法\nleft-to-right\nleft-most derivation\nk tokens look ahead\n将左因子转换为右因子\n使用parsing table\nfirst sets\nFirst(X)={t∣X→∗tα}∪{ε∣X→∗ε}\nX可以是非终结符或终结符\n一些结论：\n1.终结符的first集是自身 First(t)={t}\n2.ε∈First(X)\n当X→ε或者X→A1A2…An并且ε∈First(Ai) 对1到n都成立\n3.First(α)包含于First(X)\n当X→A1A2…Anα并且ε∈First(Ai) 对1到n都成立\n其实也就是说对于任何一个产生式的右侧的第一个符号Y都是有First(Y)包含于First(X)（？）\nT[A,t]=alpha\nfollow sets\nFollow(X)={t∣S→∗βXtδ}\n并不是说A可以推导t，而是说t可以在某个推导中紧跟在A后\n一些结论：\n1.EOF ∈Follow(S)\n2.First(β)-{ε}包含于Follow(X) 对于A→αXβ\n3.Follow(A)包含于Follow(X) 对于A→αXβ ε∈First(β)\n找Follow set应当关注符号在右边的出现（产生）\n正则表达式到NFA\n有几种固定的模式将各种运算符结合起来\nNFA到DFA\n利用空串转移的若干状态都合成为一个新状态\nDFA化简\n一开始划分为接受状态集合和其他状态集合\n观察对于输入，整个状态集合是否产生相同的输出（指输出同属一个集合）\n南大编译原理学习记录 §\nKnuth在算法分析（计算复杂的时间复杂度？）方面有很大贡献，此外被人忽视的是他在程序语言设计上的贡献，他有一本LR语法分析的论文？\n编译器重点好像在后端阶段，而我们的课程集中在前半阶段（已经成熟了）。\n符号表中存在嵌套关系（函数作用域？）\nclang的读音 不是c lang\nclang可用来生成llvm中间代码\nclang -emit-llvm -S hello.c\n//-S表示人类易读格式\ndump（打印内存信息）抽象语法树\nclang -Xclang -ast-dump hello.c\n//不需要该代码可运行\n分词\nclang -fsyntax-only -Xclang -dump-tokens hello.c\nantlr支持非贪婪匹配 优先级匹配（使用的表达式） 整体匹配（不会把小数拆成整数和一个以点开头的小数来识别）\n所以用antlr实现时可能不太需要注意优先级和二义性问题\n语法和语义\nnfa到dfa的转换 不动点\ndfa最小化 hopcroft 划分 死状态\n函数调用图和计算器实现的例子"},"计算方法":{"title":"计算方法","links":["插值","求积","差分","方程求根","线性方程"],"tags":[],"content":"规模缩减技术\n绝对误差\nx为准确值，x*为近似值\ne=x−x∗\n误差限\n​e​​=​x−x∗​​≤E\n相对误差\n理论式\ner​=xe​=xx−x∗​\n应用式\n有效数字\n∣e∣≤0.5×10−k\n从小数点后第k位之前到最左边的非零数之间\n或者\nx∗=±10m(x1​∗10−1+x2​∗10−2+...+xn​∗10−n)\n误差限满足\n∣x−x∗∣≤21​∗10m−n\n则有n位有效数字\n四舍五入的结果误差不超过结果末位的半个单位，得到的数都是有效数字\n有效数位越多，相对误差越小，计算结果越精确\n秦九韶算法 §\nv0​=a0​\nvk​=xvk−1​+ak​\nP=vn​\n校正技术 §\nZeno钟 §\ntk+1​=vA​s+vB​tk​​\n推导\nt∗=vA​−vB​s​t1​=t0​+Δt代入，舍去高阶无穷小量​\n开方算法\nxk+1​=21​(xk​+xk​a​)\n松弛技术 §\nF=(1−ω)F0​+ωF1​=F0​+ω(F1​−F0​)\n超松弛 F1为优 F2为劣\nF=(1+ω)F1​−ωF0​\n插值方法 §\n插值\n求积\n差分\n方程求根\n线性方程"},"计算机图形学":{"title":"计算机图形学","links":[],"tags":[],"content":"二维变换 §\n缩放变换\n{x′=ux​xy′=uy​y​\n[x′y′​]=[s0​0s​][xy​]\nNon-Uniform\n[x′y′​]=[sx​0​0sy​​][xy​]\n镜像变换\n{​x′=−xy′=y​\n[x′y′​]=[−10​01​][xy​]\nShear切变\n\n[x′y′​]=[−10​a1​][xy​]\n旋转\n默认绕原点逆时针\nRθ​=[cosθsinθ​−sinθcosθ​]R−θ​=RθT​=Rθ−1​\n线性变换\n{​x′=ax+byy′=cx+dy​\n[x′y′​]=[ac​bd​][xy​]\nx′=Mx\n齐次坐标 §\n平移变换 不是线性变换\n{​x′=x+tx​y′=x+ty​​\n引入新维度w\n2Dpoint=(x,y,1)T2DVector=(x,y,0)T\n​x′y′w′​​=​100​010​tx​ty​1​​​xy1​​=​x+tx​y+ty​1​​\n向量具有平移不变性 因而w为0\n并且保证了\nvector+vectorpoint−pointpoint+vectorpoint+point​=vector=point=point=??​​\n认为在齐次坐标中\n​xyw​​表示​x/wy/w1​​,w=0\n于是两坐标相加得到其中点\n仿射变换（先线性变换后平移）\n[x′y′​]=[ac​bd​][xy​]+[tx​ty​​]\n​x′y′1​​=​ac0​bd0​tx​ty​1​​​xy1​​\nScale\nS(sx​,sy​)=​sx​00​0sy​0​001​​\nRotation\nR(α)=​cosαsinα0​−sinαcosα0​001​​\nTranslation\nT(tx​,ty​)=​100​010​tx​ty​1​​\n逆变换 复合变换 分解\n\n三维变换 §\n3Dpoint=(x,y,z,1)T3DVector=(x,y,z,0)T\n(x,y,z,w)表示(x/w,y/w,z/w)(w=0)\n​x′y′z′1​​=​adg0​beh0​cfi0​tx​ty​tz​1​​​xyz1​​\nScale\nS(sx​,sy​,sZ​y)=​sx​000​0sy​00​00sz​0​0001​​\nRotation\nRx​(α)=​1000​0cosαsinα0​0−sinαcosα0​0001​​Ry​(α)=​cosα0−sinα0​0100​sinα0cosα0​0001​​Rz​(α)=​cosαsinα00​−sinαcosα00​0010​0001​​Rxyz​(α,β,γ)=Rx​(α)Ry​(β)Rz​(γ)\n欧拉角\n罗德里格斯旋转公式\n绕着轴n旋转alpha角 轴以原点为起点(叉乘矩阵)\nR(n,α)=cos(α)I+(1−cos(α))nnT+sin(α)​0nz​−ny​​−nz​0nx​​ny​−nx​0​​\nTranslation\nT(tx​,ty​)=​1000​0100​0010​tx​ty​tz​1​​\n观测变换 §\nmodel transformation和view transformation分别放置物体和相机\n视图view变换 让世界空间下的坐标轴在摄像机空间下表示\n定义相机\n位置e看的方向g^​向上方向(Up−Direction)t^\n使得相机放在原点 向上方向Y 看的方向-Z\n用Mview​将相机调整到该位置首先平移到原点再将g^​旋转到−Z，t^旋转到Y，于是x也旋转到了g^​×t^Mview​=Rview​Tview​Tview​=​1000​0100​0000​−xe​−ye​−ze​1​​Rview−1​=​xg^​×t^​yg^​×t^​zg^​×t^​0​xt​yt​zt​0​x−g^​​x−g^​​x−g^​​0​0001​​旋转矩阵为正交矩阵故Rview−1​=​xg^​×t^​xt​x−g^​​0​yg^​×t^​yt​y−g^​​0​zg^​×t^​zt​z−g^​​0​0001​​​\n投影Projection变换\n-正交Orthographic变换(平行线仍平行)\n-透视Perspective变换(不平行，接近人眼效果，近大远小)\n\n\n实现：将一个立方体[left,right]x[bottom,top]x[far,near]（想看到的区域)变换以原点为中心 大小2x2x2的正交立方体\n因为向-Z方向看 ‘f&lt;n’\nMortho​=​2r−l​000​02t−b​00​002n−f​0​0001​​​1000​0100​0010​−2l+r​−2t+b​−2n+f​1​​\n\n1.将frustum“挤”成cuboid  2.正交投影\n\n在齐次坐标下\n​xyz1​​→​znx​ynx​unknown1​​==​nxnyunknownz​​\n由far平面上的点的z不变 near平面的点坐标不变\n​xyn1​​→​znx​ynx​n1​​==​nxnyn2n​​\n(0​0​A​B​)​xyn1​​=n2→An+B=n2\n​00f1​​→​00f1​​==​00f2f​​\nAf+B=f2\n解得\nA=n+fB=−nf\nMpersp→ortho​=​n000​0n00​00n+f1​00−nf0​​\nfield-of-view(fovY) aspect ratio\n\ntan2fovY​=∣n∣t​aspect=tr​\nrasterize光栅化 绘制在屏幕上\n屏幕空间\nMviewport​=​2width​000​02height​00​0010​2width​2height​01​​\nrasterizing triangles into pixels\n采样\n\n叉积判断点是否在三角形内\n为了避免每次判断时遍历整个屏幕空间，引入boundingbox\n\n别的包围盒方案\n\n\nAliasing(Jaggies)\nsampling artifacts(errors/mistakes/inaccuracies)\n\n原因：信号变化太快 采样频率太低\n在采样前先滤波/模糊\n傅里叶变换：时域到频域\n\n\nfiltering滤波 抹掉特定频段\n对图片做傅里叶变换 中间低频 四周高频 亮度表示信息量 自然界的图片普遍满足\n\n假设图片在竖直方向和水平方向无穷重复 图片边界剧烈信号变换（高频） 因而产生水平竖直亮线\n\n\n\n\n滤波 平均/卷积\n卷积定理 时域乘积=频域卷积\n\n\n\n高频变多\n更大的卷积核等于更低频\n采样=重复频谱内容\n\n\n采样越快 在频谱上越稀疏\n因而解决方案 增加采样率或者先模糊（低通滤波 去掉高频信息）再采样\n\n\nMSAA\n\n\n\n\nFXAA,TAA\n画家算法\n从后往前画 overwrite in the framebuffer\n深度排序要nlogn的时间复杂度\n\nZ-Buffer\n\n\n（深度越浅颜色越深）\n\nO(n)(assuming constant converage)\n对每个采样点z-buffer\n\nshading着色-apply a material\nBlinn-Phong Reflectance Model\n对任意一个点(Shading Point),足够小都可以视作平面\n\n只考虑光线对这个点的影响，局部性，不产生阴影\n漫反射中有\n由能量守恒\n\n漫反射与观察视角无关\n高光/镜面反射只有观察角度与反射方向接近时可以观察到\n\n\np控制能看到高光的区域大小\n\n环境光照\n\n\nShading Frequencies\n\n逐面/逐顶点/逐像素\n\n\n\n\n如何找到顶点的法线-简单化的假设每个顶点的法向量是其相邻的面的法向量的(面积加权)平均\n\n\n\n如何定义物体表面每个点的性质\n三维物体的表面是一个二维平面\n\n\n找到任意一个三角形(顶点)在纹理上的对应\n因而纹理应有坐标系(u,v)\n\n\n插值问题 已知三角形顶点对应的纹理坐标求内部的对应 平滑\n\n\n三角形的重心的重心坐标是(1/3,1/3,1/3)\n\n\n应当求三维坐标中的中心坐标 而不是投影后再做\n\n\n双线性插值Billinear\n\n\n\n近处锯齿，远处摩尔纹\n近处一个像素覆盖的纹理区域小，远处大\n\n超采样解决\npoint query和range query\n直接得到范围的平均值\nmipmap\n\n\n额外开销1/4+1/16+…=1/3\n\n\n\n在D=log2L层的mipmap上该点对应一个纹素\n\n层与层之间不连续 插值\nTrilinear Interpolation\n\nMipmap局限：Overblur\n各向异性过滤Antisotropic Filtering 对性能要求不高 空间有一定要求\n\n\n\n纹理应用\n环境光贴图environment map 只记录各个方向 不记录深度\n\nspherical environment map记录环境光在球上\n\n再展开\n\n\n\n\n\n\n在局部坐标系下计算，认为法线默认向z轴正方向，在转换为世界坐标系\n\n噪声 山脉\n\n环境光遮蔽\ngeometry\n\n\n容易判定但不容易找出所有的点\n\n相反\n\n\n\n\n\n\n\n\n\n贝塞尔曲线\n\n二次贝塞尔曲线\n分别在b0b1和b1b2上找到划分为t/1-t的点\n\n三次贝塞尔曲线\n\n\nb01​(t)=(1−t)b0​+tb1​b11​(t)=(1−t)b1​+tb2​b02​(t)=(1−t)b01​+tb11​b02​(t)=(1−t)2b0​+2t(1−t)b1​+t2b2​\n给定n+1个控制点 n阶贝塞尔曲线\nbn(t)=j=0∑n​bj​Bjn​(t)Bin​(t)=(in​)ti(1−t)n−i\n\n\n\n\n样条\n\n贝塞尔曲面\n\n\n\n曲面细分\n\nLoop（人名）\n\n\n\n引入了两个新的度为3的奇异点 且（2个）非四边形面消失 之后奇异点不再增加\n\n\n\n曲面简化\n\n\n\n采用堆 便于去最小值和更新 希望找到二次度量误差最小的边更新，通过局部最优解来希望得到全局最优解 也就是贪心\n\nshadow mapping\n阴影是能被相机看到不能被光源看到的点\n\n\n\n\n\n\n\n点光源不存在软阴影\nray tracing\n软阴影和光线反弹的情况光栅化无法处理\n离线\n光线的定义\n1.直线传播2.不互相碰撞3.从光源运动到眼睛\n利用光线传播的可逆性(reciprocity)，也可以认为人眼发出光线运动到光源\n\n\n\nrecursive(whitted-style)ray tracing\n\n\n\n确认光线和物体表面的交点\n\n\n解得\nt=2a−b±b2−2ac​​\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n不要让树退化成链表 换不同的轴划分\n找中位数 O(N)快速选择算法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n点光源换成面 对立体角积分\n\n\n\n\n\n蒙特卡洛\n\n\n光线数量指数增加\n\n\n递归出口\n\n弹射次数期望?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"集合论":{"title":"集合论","links":["集合论","数理逻辑"],"tags":[],"content":"集合 §\n互异{1,2,3,3,3}={1,2,3}\n本书中规定集合的元素是集合\nA⊆B ⇔∀x (x∈A→x∈B)\nA=B ⇔ A⊆B∧B⊆A\nA⊂B ⇔ A⊆B∧A≠B\nA⊈B ⇔ ∃x (x∈A∧x∉B)\n空集 ∅：不含有任何元素的集合。\n空集是任何集合的子集。\n∅ 是惟一的\n∅≠{∅}\nn元集：含有n个元素的集合\n幂集：P(A)={ x | x ⊆ A }\n全集 E ：包含了所有集合的集合\n全集具有相对性：与问题有关，不存在绝对的全集\nA∪B = {x | x∈A∨x∈B}\nA∩B = {x | x∈A∧x∈B}\n相对补 A−B = {x | x∈A∧x∉B}\n对称差 A⊕B = (A−B)∪(B−A)\n绝对补 ∼A = E−A\nA ⊆ B ⇔ A−B = ∅\nA∩B = ∅  ⇔ A−B = A\n广义并 ∪A = { x | ∃z ( z∈A ∧ x∈z )}\n元素的元素构成的集合\n\n∪∅=∅\n广义交 ∩A = { x | ∀z( z∈A → x∈z )}\n所有元素的公共元素构成的集合\n∩∅无意义\n单元集{x} 的广义并和广义交都等于x\n并，交，相对补，对称差 优先顺序由括号确定\n广义，幂集，绝对补，运算由右向左进行\n第二行的运算优先\n\n\n有序对 §\n由两个元素 x 和 和 y ，按照一定的顺序组成的二元组\n&lt;x,y&gt;=&lt;u,v&gt; ⇔ x=u∧y=v\n笛卡尔积 §\n设A,B 为集合，\nA×B = {&lt;x,y&gt;| x∈A∧y∈B}\n\n二元关系 §\n如果一个集合满足以下条件之一：\n(1) 集合非空, 且它的元素都是有序对\n(2) 集合是空集\n则称该集合为一个 二元关系, 简称为关系，记作R.\n如果&lt;x,y&gt; ∈R, 可记作xRy ；如果&lt;x,y&gt;∉R, 则记作x反斜杠Ry\n设A,B 为集合, A×B 的任何子集所定义的二元关系叫做 从A到B 的二元关系, 当A=B 时则叫做A上的二元关系\n若A和B的元素数量分别为m和n，AxB的元素数量为mn，二元关系数量为2\n以下是A上的各种关系\n对于任何集合A，空集∅是A x A的子集，叫做A上的空关系\n全域关系 §\nEA​={&lt;x,y&gt;∣x∈A∧y∈A}=A×A\n恒等关系 §\nIA​={&lt;x,x&gt;∣x∈A}\n小于等于关系 §\nLA​={&lt;x,y&gt;∣x,y∈A∧x≤y}\n（A 为实数子集）\n整除关系 §\nDB​={&lt;x,y&gt;∣x,y∈B∧x∣y}\n（A 为非0 整数子集）\n包含关系 §\nR⊆​={&lt;x,y&gt;∣x,y∈A∧x⊆y}\n（A是集合族）\nR 的关系矩阵是布尔矩阵MR​=[rij​]m×n​，其中rij​=1⇔&lt;xi​,yj​&gt;∈R\n又称为R的邻接矩阵\n布尔矩阵的并和交运算 §\n对应元素作并和交\n布尔矩阵的积运算 §\nA⊙B=C=(cij​)\ncij​={   1    0 ​∃k,aik​=1andbkj​=1else​​\n关系图 若A= {x 1 , x 2 , …, x m } ，R 是从A 上的关系，R 的关系图是G R =&lt;A, R&gt;, 其中A 为结点集，R 为边集. 如果&lt;x i ,x j &gt; 属于\n关系R ，在图中就有一条从 x i 到 到 x j 的有向边.\n关系的 定义域 、 值域 与 域 分别定义为\ndomR = { x | ∃y (&lt;x,y&gt;∈R) }\nranR = { y | ∃x (&lt;x,y&gt;∈R) }\nfldR = domR ∪ ranR\n关系的逆运算 §\nR−1={&lt;y,x&gt;∣&lt;x,y&gt;∈R}\n关系矩阵作转置\n\n关系的合成运算 §\nR ° S = { &lt;x, z&gt; | ∃y (&lt;x, y&gt;∈R ∧ &lt;y, z&gt;∈S) }\n合成运算的关系图形式 §\n左边标R的定义域，中间标R的值域和S的定义域的并，右边标S的值域，完成R和S的关系图绘制，找从左到右的通路\n合成运算的关系矩阵形式 §\n矩阵作积运算\n关系的幂运算 §\n\n设R 为二元关系, A 是集合\n(1) R 在A 上的 限制 记作 R ↾ A, 其中R ↾ A = { &lt;x,y&gt; | xRy ∧x∈A }\n(2) A 在R 下的 像 记作R[A], 其中R[A]=ran(R ↾ A)\nR 在A 上的限制 R ↾ A 是 R 的子关系，即 R ↾ A ⊆ R\nA 在R下的像 R[A] 是 ranR 的子集，即 R[A]⊆ ranR\n逆运算优先于关系运算优先于集合运算\ndomF−1=ranFranF−1=domF(F°G)°H=F°(G°H)(F°G)−1=G−1°F−1R°IA​=IA​°R=R(R为A上的关系)F°(G∪H)=F°G∪F°H(G∪H)°F=G°F∪H°FF°(G∩H)⊆F°G∩F°H(G∩H)°F⊆G°F∩H°FF↾(A∪B)=F↾A∪F↾BF[A∪B]=F[A]∪F[B]F↾(A∩B)=F↾A∩F↾BF[A∩B]⊆F[A]∩F[B]​\n自反/反自反关系 §\n&lt;x,x&gt;都在/都不在\n设 R 为A 上的关系,\n(1) 若 ∀x(x ∈A→&lt;x,x&gt;∈R), 则称 R 在 A 上是 自反的\n(2) 若 ∀ x(x ∈A→&lt;x,x&gt;∉R), 则称 R 在  A 上是 反自反的\nA上的全域，恒等，小于等于，整除，包含关系都是自反关系\nA上的小于关系和真包含关系都是反自反关系\n对称/反对称关系 §\n&lt;x,y&gt;在&lt;y,x&gt;就在/不存在&lt;x,x&gt;\n若∀x∀y( x,y ∈A∧&lt;x,y&gt; ∈R→&lt;y,x&gt; ∈R), 则称 R 为 A 上 对称关系\n若∀x∀y( x,y ∈A∧&lt;x,y&gt; ∈R∧&lt;y,x&gt; ∈R→x=y), 则称 R 为A 上的 反对称关系\nA 上的全域，恒等，空关系是对称关系\n恒等，空关系是反对称关系\n传递关系 §\n若∀x∀y∀z(x,y,z ∈A∧&lt;x,y&gt; ∈R∧&lt;y,z&gt; ∈R→&lt;x,z&gt; ∈R),则称 R 是A 上的 传递 关系\nA上的全域，恒等，空，小于等于，整除，包含，小于，真包含都是传递关系\n\n\n关系性质的保守性\n\n闭包 §\n\n\n\n\n等价关系 §\n设R 为非空集合上的关系. 如果R 是自反的、对称的和传递的, 则称R 为A上的 等价关系. 设 R 是一个等价关系, 若&lt;x,y&gt; ∈R, 称x 等价于y, 记做x～y\n等价类 §\n设R 为非空集合A 上的等价关系, ∀ x ∈A ，令[x]R​={y∣y∈A∧xRy} 称[x] R 为x 关于R 的等价类, 简称为x 的 等价类, 简记为[x]\n\n商集 §\n设  R 为非空集合A 上的等价关系, 以 R 的所有等价类作为元素的集合称为A 关于R 的 商集, 记做A/R,\nA/R = {[x]R | x ∈A}\n划分 §\n设A 为非空集合, 若A 的子集族π(π ⊆ P(A)) 满足:\n(1) ∅ ∉ π\n(2) ∀x∀y(x,y∈π ∧x≠y→x∩y= ∅)\n(3) ∪π = A\n则称π 是A 的一个 划分, 称π 中的元素为A 的 划分块\n给定集合 A 上的等价关系 R, 则商集 A/R 是 A 的一个划分\n集合A 的一个划分π 诱导出A 上的一个等价关系R. R定义为R= {&lt;x,y&gt;| x,y ∈A 且x,y 在π 的同一分块中}\n设R 1 和 和R 2 为非空集合 为非空集合A 上的一个等价关系,则 R 1 = R 2 iff A/R 1 = A/R 2\n偏序关系 §\n非空集合A 上的自反、反对称和传递的关系，\n记作≼. 设≼为偏序关系, 如果 &lt;x, y&gt; ∈ ≼, 则记作 x ≼ y\n可比 §\n设 R 为非空集合A 上的偏序关系,\n(1) x, y ∈A, x 与y 可比  ⇔ x ≼ y ∨y ≼ x\n(2) 任取元素 x 和 y, 可能有下述几种情况发生：\nx ≺  y (或  y ≺  x), x＝y, x与y不可比\nR 为非空集合A 上的偏序关系, §\n(1) ∀x,y ∈A, x 与y 都是可比的，则称R 为 全序\n覆盖 §\nx,y ∈A, 如果 如果 x≺y 且不存在  z ∈A 使得  x≺z≺y, 则称 y覆盖x\n偏序集 §\n集合A 和A上的偏序关系 ≼一起叫做 一起叫做 偏序集, 记作&lt;A,≼&gt;\n哈斯图 §\n简化的关系图\n1.不画环\n2.a到b有边，b到c有边，则不画a到c的边\n3.被指的点放在高的位置，指出去的点放在低的位置，因此不用标明指向方向\n特殊元素 §\n\n只能在子集B中找\n如果有孤立节点大概就没有最大最小元\n\n在整个A中找\n能和B中元素构成一个树的形状的根大概是上界 反向的形状就是下界\n证明R 在A 上自反\n任取x\nx∈ A  ⇒ ……………………..….……. ⇒ &lt;x,x&gt;∈R\n证明R 在A 上对称\n任取&lt;x,y&gt;\n&lt;x,y&gt; ∈ R ⇒  ………………………………. ⇒ &lt;y,x&gt;∈ R\n证明R 在A 上反对称\n任取&lt;x,y&gt;\n&lt;x,y&gt;∈ R∧ &lt;y,x&gt;∈ R ⇒  …………………….. ⇒  x = y\n证明R 在A 上传递\n任取&lt;x,y&gt;,&lt;y,z&gt;\n&lt;x,y&gt;∈ R∧ &lt;y,z&gt;∈ R ⇒  …………………….. ⇒  &lt;x,z&gt;∈ R\n函数 §\n设 F 为二元关系, 若∀x ∈domF 都存在唯一的y∈ ranF 使 xFy 成立, 则称 F 为函数\n对于函数F, 如果有 xFy, 则记作 y=F(x), 并称 y 为F 在 x 的值\n设F, G 为函数, 则 F=G ⇔ F⊆G ∧G⊆F\n如果两个函数F 和 G 相等, 一定满足下面两个条件：\n(1) domF=domG\n(2) ∀x ∈domF=domG 都有F(x)=G(x)\n设A, B 为集合, 如果f为函数, domf=A, ranf⊆B,则称 f 为 从A 到B的函数, 记作 f:A→B\n所有从A 到B 的函数的集合记作B A , 符号化表示为BA={f∣f：A→B}\n\n设  f:A→B,\n(1) 若 ranf=B, 则称 f:A→B是 满射 的\n(2) 若 ∀y ∈ranf 都存在唯一的 x ∈A得 使得 f(x)=y, 则称 f:A→B是 单射 的\n(3) 若  f:A→B 既是满射又是单射的, 则称 f:A→B是 双射\n\n\n\n函数的复合 §\n设F, G 是函数, 则F ° G 也是函数, 且满足\n(1) dom(F ° G)={x|x ∈domF ∧F(x) ∈domG}\n(2) ∀x ∈dom(F ° G) 有F ° G(x)=G(F(x))\n设F, G, H 为函数, 则(F ° G) ° H 和F ° (G ° H) 都是函数, 且 (F ° G) ° H=F °  (G ° H)\n设 f:A→B, g:B→C, 则 f ° g:A→C, 且∀x ∈A 都有f ° g(x)=g(f(x))\n设f:A→B, g:B→C\n(1) 如果 f:A→B, g:B→C 是满射的, 则 f ° g:A→C 也是满射的\n(2) 如果 f:A→B, g:B→C 是单射的, 则 f ° g:A→C 也是单射的\n(3) 如果 f:A→B, g:B→C 是双射的, 则 f ° g:A→C 也是双射的\n设 f:A →B, 则\nf=f°IB​=IA​°f\n逆函数 §\n反函数存在的条件\n(1) 任给函数F, 它的逆不一定是函数,\n(2) 任给单射函数 f:A→B, 则f − −1 是函数, 且是从ranf 到A 的双\n射函数, 但不一定是从B 到A 的双射函数\n(3) 对于双射函数 f:A→B, f − −1 :B→A 是从B 到A的双射函数\n设 f:A→B 是双射的, 则f−1°f=IB​,f°f−1=IA​\n基数 §\n用来衡量集合大小的一个概念 用来衡量集合大小的一个概念. 对于有限集合集来说, 集合的基数就是其中所含元素的个数\n等势 §\n设A, B 是集合, 如果存在着从A 到B 的双射函数, 就称A 和B 是 等势的, 记作A≈B. 如果A 不与B 等势, 则记作A≈B.也有基数相等\n注：通常将A的 基数为 记为 |A|.\n重要等势结果\nN ≈ Z ≈ Q ≈ N ×N\n任何实数区间都与实数集合R 等势\n{0,1}N≈R\n实数轴上所有开区间之间，闭区间等势\n任何实数开区间都与R等势\n自然数集N和闭区间[0,1]不等势"}}